
<!-- vim-markdown-toc GFM -->

* [js]
	* [快速入门]
		* [对象]
		* [基本语法]
			* [语法]
			* [注释]
			* [大小写]
		* [数组]
			* [indexOf]
			* [slice]
			* [push和pop]
			* [unshift和shift]
			* [sort]
			* [reverse]
			* [splice]
			* [concat]
			* [join]
			* [多维数组]
			* [小结]
		* [条件判断]
			* [多行条件判断]
			* [练习]
		* [数据类型和变量]
			* [数据类型]
			* [Number]
			* [字符串]
			* [布尔值]
			* [比较运算符]
			* [null和undefined]
			* [数组]
			* [对象]
			* [变量]
			* [strict模式]
		* [iterable]
		* [Map和Set]
			* [Map]
			* [Set]
			* [小结]
		* [循环]
			* [循环]
			* [练习]
			* [for ... in]
			* [while]
			* [do ... while]
			* [练习]
			* [小结]
		* [字符串]
			* [多行字符串]
			* [模板字符串]
			* [操作字符串]
			* [toUpperCase]
			* [toLowerCase]
			* [indexOf]
			* [substring]
	* [underscore]
		* [Collections]
			* [map/filter]
			* [every / some]
			* [max / min]
			* [groupBy]
			* [shuffle / sample]
		* [Chaining]
			* [小结]
		* [Arrays]
			* [first / last]
			* [flatten]
			* [zip / unzip]
			* [object]
			* [range]
			* [练习]
		* [Functions]
			* [bind]
			* [partial]
			* [memoize]
			* [once]
			* [delay]
		* [Objects]
			* [keys / allKeys]
			* [values]
			* [mapObject]
			* [invert]
			* [extend / extendOwn]
			* [clone]
			* [isEqual]
	* [期末总结]
	* [Node.js]
		* [模块]
			* [CommonJS规范]
			* [结论]
			* [深入了解模块原理]
			* [module.exports vs exports]
			* [结论]
			* [练习]
			* [参考源码]
		* [Web开发]
		* [搭建Node开发环境]
			* [Visual Studio Code]
			* [安装Visual Studio Code]
			* [运行和调试JavaScript]
			* [参考源码]
		* [自动化工具]
		* [基本模块]
			* [global]
			* [process]
			* [判断JavaScript执行环境]
			* [参考源码]
		* [第一个Node程序]
			* [命令行模式和Node交互模式]
			* [使用严格模式]
			* [小结]
			* [参考源码]
		* [安装Node.js和npm]
			* [安装Node.js]
			* [npm]
			* [小结]
	* [jQuery]
		* [扩展]
			* [编写jQuery插件]
			* [针对特定元素的扩展]
			* [小结]
		* [事件]
			* [鼠标事件]
			* [键盘事件]
			* [其他事件]
			* [事件参数]
			* [取消绑定]
			* [事件触发条件]
			* [浏览器安全限制]
			* [练习]
		* [选择器]
			* [按ID查找]
			* [按tag查找]
			* [按class查找]
			* [按属性查找]
			* [组合查找]
			* [多项选择器]
			* [练习]
		* [动画]
			* [show / hide]
			* [slideUp / slideDown]
			* [fadeIn / fadeOut]
			* [自定义动画]
			* [串行动画]
			* [为什么有的动画没有效果]
			* [练习]
		* [操作DOM]
			* [修改Text和HTML]
			* [修改CSS]
			* [显示和隐藏DOM]
			* [获取DOM信息]
			* [操作表单]
		* [AJAX]
			* [ajax]
			* [get]
			* [post]
			* [getJSON]
			* [安全限制]
	* [浏览器]
		* [Canvas]
			* [绘制形状]
			* [绘制文本]
			* [练习]
		* [Promise]
		* [操作文件]
			* [File API]
			* [回调]
		* [浏览器对象]
			* [window]
			* [navigator]
			* [screen]
			* [location]
			* [document]
			* [history]
		* [操作表单]
			* [获取值]
			* [设置值]
			* [HTML5控件]
			* [提交表单]
			* [练习]
		* [操作DOM]
			* [练习]
		* [AJAX]
			* [安全限制]
			* [CORS]
	* [函数]
		* [闭包]
			* [函数作为返回值]
			* [闭包]
			* [脑洞大开]
		* [变量作用域与解构赋值]
			* [变量提升]
			* [全局作用域]
			* [名字空间]
			* [局部作用域]
			* [常量]
			* [解构赋值]
			* [使用场景]
		* [函数定义和调用]
			* [定义函数]
			* [调用函数]
			* [arguments]
			* [rest参数]
			* [小心你的return语句]
			* [练习]
		* [高阶函数]
		* [箭头函数]
			* [this]
			* [练习]
		* [方法]
			* [apply]
			* [装饰器]
		* [generator]
			* [练习]
	* [JavaScript简介]
	* [错误处理]
		* [异步错误处理]
		* [错误传播]
	* [React]
		* [第一个React应用]
		* [元素渲染]
		* [组件]
		* [组件和状态]
	* [面向对象编程]
		* [原型继承]
			* [小结]
		* [创建对象]
			* [构造函数]
			* [忘记写new怎么办]
			* [练习]
		* [class继承]
			* [class继承]
			* [练习]
	* [标准对象]
		* [JSON]
			* [序列化]
			* [反序列化]
			* [练习]
		* [RegExp]
			* [进阶]
			* [RegExp]
			* [切分字符串]
			* [分组]
			* [贪婪匹配]
			* [全局搜索]
			* [小结]
			* [练习]
		* [Date]
			* [时区]
			* [练习]

<!-- vim-markdown-toc -->
# js
## 快速入门
### 对象
1. JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。

2. JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他：

```
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
```
3. JavaScript用一个

4. 上述对象申明了一个

```
xiaoming.name; // '小明'
xiaoming.birth; // 1990
```
5. 访问属性是通过

```
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```
6. None

```
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```
7. 也可以用

8. 实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。

9. 如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回

```
'use strict';

var xiaoming = {
    name: '小明'
};
----
console.log(xiaoming.name);
console.log(xiaoming.age); // undefined
```
10. 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：

```
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```
11. 如果我们要检测

```
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```
12. 不过要小心，如果

```
'toString' in xiaoming; // true
```
13. 因为

14. 要判断一个属性是否是

```
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```
### 基本语法
#### 语法 
1. JavaScript的语法和Java语言类似，每个语句以

```
让JavaScript引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。在本教程中，我们不会省略;，所有语句都会添加;。
```
2. 例如，下面的一行代码就是一个完整的赋值语句：

```
var x = 1;
```
3. 下面的一行代码是一个字符串，但仍然可以视为一个完整的语句：

```
'Hello, world';
```
4. 下面的一行代码包含两个语句，每个语句用

```
var x = 1; var y = 2; // 不建议一行写多个语句!
```
5. 语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行

```
if (2 > 1) {
    x = 1;
    y = 2;
    z = 3;
}
```
6. 注意花括号

7. None

```
if (2 > 1) {
    x = 1;
    y = 2;
    z = 3;
    if (x < y) {
        z = 4;
    }
    if (x > y) {
        z = 5;
    }
}
```
8. JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。遇到这种情况，需要把部分代码抽出来，作为函数来调用，这样可以减少代码的复杂度。

#### 注释 
1. 以

```
// 这是一行注释
alert('hello'); // 这也是注释
```
2. 另一种块注释是用

```
/* 从这里开始是块注释
仍然是注释
仍然是注释
注释结束 */
```
3. 练习：

4. 分别利用行注释和块注释把下面的语句注释掉，使它不再执行：

```
// 请注释掉下面的语句:
----
alert('我不想执行');
alert('我也不想执行');
```
#### 大小写 
1. 请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。

### 数组
1. JavaScript的

2. 要取得

```
var arr = [1, 2, 3.14, 'Hello', null, true];
arr.length; // 6
```
3. None

```
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
```
4. None

```
var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']
```
5. None

```
var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
```
6. 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的

#### indexOf 
1. 与String类似，

```
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```
2. 注意了，数字

#### slice 
1. None

```
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
```
2. 注意到

3. 如果不给

```
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```
#### push和pop 
1. None

```
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
arr; // []
```
#### unshift和shift 
1. 如果要往

```
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
arr; // []
```
#### sort 
1. None

```
var arr = ['B', 'C', 'A'];
arr.sort();
arr; // ['A', 'B', 'C']
```
2. 能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。

#### reverse 
1. None

```
var arr = ['one', 'two', 'three'];
arr.reverse(); 
arr; // ['three', 'two', 'one']
```
#### splice 
1. None

```
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```
#### concat 
1. None

```
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```
2. None

3. 实际上，

```
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```
#### join 
1. None

```
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```
2. 如果

#### 多维数组 
1. 如果数组的某个元素又是一个

```
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```
2. 上述

3. 练习：如何通过索引取到

```
'use strict';
var arr = [[1, 2, 3], [400, 500, 600], '-'];
----
var x = ??;
----
console.log(x); // x应该为500
```
#### 小结 
1. None

2. 练习：在新生欢迎会上，你已经拿到了新同学的名单，请排序后显示：

```
'use strict';
var arr = ['小明', '小红', '大军', '阿黄'];
----
console.log('???');
```
### 条件判断
1. JavaScript使用

```
var age = 20;
if (age >= 18) { // 如果age >= 18为true，则执行if语句块
    alert('adult');
} else { // 否则执行else语句块
    alert('teenager');
}
```
2. 其中

```
var age = 20;
if (age >= 18)
    alert('adult');
else
    alert('teenager');
```
3. 省略

```
var age = 20;
if (age >= 18)
    alert('adult');
else
    console.log('age < 18'); // 添加一行日志
    alert('teenager'); // <- 这行语句已经不在else的控制范围了
```
4. 上述代码的

5. 相反地，有

```
var age = 20;
if (age >= 18) {
    alert('adult');
} else {
    console.log('age < 18');
    alert('teenager');
}
```
6. 这就是为什么我们建议永远都要写上

#### 多行条件判断 
1. 如果还要更细致地判断条件，可以使用多个

```
var age = 3;
if (age >= 18) {
    alert('adult');
} else if (age >= 6) {
    alert('teenager');
} else {
    alert('kid');
}
```
2. 上述多个

```
var age = 3;
if (age >= 18) {
    alert('adult');
} else {
    if (age >= 6) {
        alert('teenager');
    } else {
        alert('kid');
    }
}
```
3. 但是我们通常把

4. None

5. 试解释为什么下面的代码显示的是

```
'use strict';
var age = 20;
----
if (age >= 6) {
    console.log('teenager');
} else if (age >= 18) {
    console.log('adult');
} else {
    console.log('kid');
}
```
6. 由于

7. 如果

```
var s = '123';
if (s.length) { // 条件计算结果为3
    //
}
```
8. JavaScript把

#### 练习 
1. 小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：

2. 


3. 用

```
'use strict';

var height = parseFloat(prompt('请输入身高(m):'));
var weight = parseFloat(prompt('请输入体重(kg):'));
----
var bmi = ???;
if ...
```
### 数据类型和变量
#### 数据类型 
1. 计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在JavaScript中定义了以下几种数据类型：

#### Number 
1. JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：

```
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```
2. 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：

3. Number可以直接做四则运算，规则和数学一致：

```
1 + 2; // 3
(1 + 2) * 5 / 2; // 7.5
2 / 0; // Infinity
0 / 0; // NaN
10 % 3; // 1
10.5 % 3; // 1.5
```
4. 注意

#### 字符串 
1. 字符串是以单引号'或双引号"括起来的任意文本，比如

#### 布尔值 
1. 布尔值和布尔代数的表示完全一致，一个布尔值只有

```
true; // 这是一个true值
false; // 这是一个false值
2 > 1; // 这是一个true值
2 >= 3; // 这是一个false值
```
2. None

```
true && true; // 这个&&语句计算结果为true
true && false; // 这个&&语句计算结果为false
false && true && false; // 这个&&语句计算结果为false
```
3. None

```
false || false; // 这个||语句计算结果为false
true || false; // 这个||语句计算结果为true
false || true || false; // 这个||语句计算结果为true
```
4. None

```
! true; // 结果为false
! false; // 结果为true
! (2 > 5); // 结果为true
```
5. 布尔值经常用在条件判断中，比如：

```
var age = 15;
if (age >= 18) {
    alert('adult');
} else {
    alert('teenager');
}
```
#### 比较运算符 
1. 当我们对Number做比较时，可以通过比较运算符得到一个布尔值：

```
2 > 5; // false
5 >= 2; // true
7 == 7; // true
```
2. 实际上，JavaScript允许对任意数据类型做比较：

```
false == 0; // true
false === 0; // false
```
3. 要特别注意相等运算符

4. 第一种是

5. 第二种是

6. 由于JavaScript这个设计缺陷，

7. 另一个例外是

```
NaN === NaN; // false
```
8. 唯一能判断

```
isNaN(NaN); // true
```
9. 最后要注意浮点数的相等比较：

```
1 / 3 === (1 - 2 / 3); // false
```
10. 这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：

```
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```
#### null和undefined 
1. None

2. 在其他语言中，也有类似JavaScript的

3. JavaScript的设计者希望用

#### 数组 
1. 数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：

```
[1, 2, 3.14, 'Hello', null, true];
```
2. 上述数组包含6个元素。数组用

3. 另一种创建数组的方法是通过

```
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
```
4. 然而，出于代码的可读性考虑，强烈建议直接使用

5. 数组的元素可以通过索引来访问。请注意，索引的起始值为

```
var arr = [1, 2, 3.14, 'Hello', null, true];
arr[0]; // 返回索引为0的元素，即1
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```
#### 对象 
1. JavaScript的对象是一组由键-值组成的无序集合，例如：

```
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```
2. JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述

3. 要获取一个对象的属性，我们用

```
person.name; // 'Bob'
person.zipcode; // null
```
#### 变量 
1. 变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。

2. 变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、

```
var a; // 申明了变量a，此时a的值为undefined
var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1
var s_007 = '007'; // s_007是一个字符串
var Answer = true; // Answer是一个布尔值true
var t = null; // t的值是null
```
3. 变量名也可以用中文，但是，请不要给自己找麻烦。

4. 在JavaScript中，使用等号

```
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```
5. 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：

```
int a = 123; // a是整数类型变量，类型用int申明
a = "ABC"; // 错误：不能把字符串赋给整型变量
```
6. 和静态语言相比，动态语言更灵活，就是这个原因。

7. 请不要把赋值语句的等号等同于数学的等号。比如下面的代码：

```
var x = 10;
x = x + 2;
```
8. 如果从数学上理解

9. 要显示变量的内容，可以用

```
// 打印变量x
----
var x = 100;
console.log(x);
```
10. 使用

#### strict模式 
1. JavaScript在设计之初，为了方便初学者学习，并不强制要求用

```
i = 10; // i现在是全局变量
```
2. 在同一个页面的不同的JavaScript文件中，如果都不用

3. 使用

4. 为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过

5. 启用strict模式的方法是在JavaScript代码的第一行写上：

```
'use strict';
```
6. 这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。

7. 来测试一下你的浏览器是否能支持strict模式：

```
'use strict';
// 如果浏览器支持strict模式，
// 下面的代码将报ReferenceError错误:
----
abc = 'Hello, world';
console.log(abc);
```
8. 运行代码，如果浏览器报错，请修复后再运行。如果浏览器不报错，说明你的浏览器太古老了，需要尽快升级。

9. 不用

### iterable
1. 遍历

2. 具有

3. None

```
'use strict';
var a = [1, 2, 3];
for (var x of a) {
}
console.log('你的浏览器支持for ... of');
----
// 请直接运行测试
```
4. 用

```
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + '=' + x[1]);
}
```
5. 你可能会有疑问，

6. None

7. 当我们手动给

```
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x in a) {
    console.log(x); // '0', '1', '2', 'name'
}
```
8. None

9. None

```
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    console.log(x); // 'A', 'B', 'C'
}
```
10. 这就是为什么要引入新的

11. 然而，更好的方式是直接使用

```
'use strict';
var a = ['A', 'B', 'C'];
----
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    console.log(element + ', index = ' + index);
});
```
12. None

13. None

```
var s = new Set(['A', 'B', 'C']);
s.forEach(function (element, sameElement, set) {
    console.log(element);
});
```
14. None

```
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
m.forEach(function (value, key, map) {
    console.log(value);
});
```
15. 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得

```
var a = ['A', 'B', 'C'];
a.forEach(function (element) {
    console.log(element);
});
```
### Map和Set
1. JavaScript的默认对象表示方式

2. 但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。

3. 为了解决这个问题，最新的ES6规范引入了新的数据类型

```
'use strict';
var m = new Map();
var s = new Set();
console.log('你的浏览器支持Map和Set！');
----
// 直接运行测试
```
#### Map 
1. None

2. 举个例子，假设要根据同学的名字查找对应的成绩，如果用

```
var names = ['Michael', 'Bob', 'Tracy'];
var scores = [95, 75, 85];
```
3. 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。

4. 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：

```
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```
5. 初始化

```
var m = new Map(); // 空Map
m.set('Adam', 67); // 添加新的key-value
m.set('Bob', 59);
m.has('Adam'); // 是否存在key 'Adam': true
m.get('Adam'); // 67
m.delete('Adam'); // 删除key 'Adam'
m.get('Adam'); // undefined
```
6. 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：

```
var m = new Map();
m.set('Adam', 67);
m.set('Adam', 88);
m.get('Adam'); // 88
```
#### Set 
1. None

2. 要创建一个

```
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
```
3. 重复元素在

```
var s = new Set([1, 2, 3, 3, '3']);
s; // Set {1, 2, 3, "3"}
```
4. 注意数字

5. 通过

```
s.add(4);
s; // Set {1, 2, 3, 4}
s.add(4);
s; // 仍然是 Set {1, 2, 3, 4}
```
6. 通过

```
var s = new Set([1, 2, 3]);
s; // Set {1, 2, 3}
s.delete(3);
s; // Set {1, 2}
```
#### 小结 
1. None

### 循环
#### 循环 
1. 要计算1+2+3，我们可以直接写表达式：

```
1 + 2 + 3; // 6
```
2. 要计算1+2+3+...+10，勉强也能写出来。

3. 但是，要计算1+2+3+...+10000，直接写表达式就不可能了。

4. 为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。

5. JavaScript的循环有两种，一种是

```
var x = 0;
var i;
for (i=1; i<=10000; i++) {
    x = x + i;
}
x; // 50005000
```
6. 让我们来分析一下

7. 


#### 练习 
1. 利用

```
'use strict';
----
var x = ?;
var i;
for ...
----
if (x === 3628800) {
    console.log('1 x 2 x 3 x ... x 10 = ' + x);
}
else {
    console.log('计算错误');
}
```
2. None

```
var arr = ['Apple', 'Google', 'Microsoft'];
var i, x;
for (i=0; i<arr.length; i++) {
    x = arr[i];
    console.log(x);
}
```
3. None

```
var x = 0;
for (;;) { // 将无限循环下去
    if (x > 100) {
        break; // 通过if判断来退出循环
    }
    x ++;
}
```
#### for ... in 
1. None

```
var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    console.log(key); // 'name', 'age', 'city'
}
```
2. 要过滤掉对象继承的属性，用

```
var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    if (o.hasOwnProperty(key)) {
        console.log(key); // 'name', 'age', 'city'
    }
}
```
3. 由于

```
var a = ['A', 'B', 'C'];
for (var i in a) {
    console.log(i); // '0', '1', '2'
    console.log(a[i]); // 'A', 'B', 'C'
}
```
4. None

#### while 
1. None

2. None

```
var x = 0;
var n = 99;
while (n > 0) {
    x = x + n;
    n = n - 2;
}
x; // 2500
```
3. 在循环内部变量

#### do ... while 
1. 最后一种循环是

```
var n = 0;
do {
    n = n + 1;
} while (n < 100);
n; // 100
```
2. 用

#### 练习 
1. 请利用循环遍历数组中的每个名字，并显示

```
'use strict';
var arr = ['Bart', 'Lisa', 'Adam'];
----
for ...
```
2. 请尝试

#### 小结 
1. 循环是让计算机做重复任务的有效的方法，有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。JavaScript的死循环会让浏览器无法正常显示或执行当前页面的逻辑，有的浏览器会直接挂掉，有的浏览器会在一段时间后提示你强行终止JavaScript的执行，因此，要特别注意死循环的问题。

2. 在编写循环代码时，务必小心编写初始条件和判断条件，尤其是边界值。特别注意

### 字符串
1. JavaScript的字符串就是用

2. 如果

3. 如果字符串内部既包含

```
'I\'m \"OK\"!';
```
4. 表示的字符串内容是：

5. 转义字符

6. ASCII字符可以以

```
'\x41'; // 完全等同于 'A'
```
7. 还可以用

```
'\u4e2d\u6587'; // 完全等同于 '中文'
```
#### 多行字符串 
1. 由于多行字符串用

```
`这是一个
多行
字符串`;
```
2. None

```
┌─────┐ ┌─────┬─────┬─────┬─────┐
│ ESC │ │ F1  │ F2  │ F3  │ F4  │
│     │ │     │     │     │     │
└─────┘ └─────┴─────┴─────┴─────┘
┌─────┬─────┬─────┬─────┬─────┐
│  ~  │  !  │  @  │  #  │  $  │
│  `  │  1  │  2  │  3  │  4  │
├─────┴──┬──┴──┬──┴──┬──┴──┬──┘
│        │     │     │     │
│  tab   │  Q  │  W  │  E  │
├────────┴──┬──┴──┬──┴──┬──┘
│           │     │     │
│ caps lock │  A  │  S  │
└───────────┴─────┴─────┘
```
3. 练习：测试你的浏览器是否支持ES6标准，如果不支持，请把多行字符串用

```
// 如果浏览器不支持ES6，将报SyntaxError错误:
----
console.log(`多行
字符串
测试`);
```
#### 模板字符串 
1. 要把多个字符串连接起来，可以用

```
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
alert(message);
```
2. 如果有很多变量需要连接，用

```
var name = '小明';
var age = 20;
var message = `你好, ${name}, 你今年${age}岁了!`;
alert(message);
```
3. 练习：测试你的浏览器是否支持ES6模板字符串，如果不支持，请把模板字符串改为

```
'use strict';

// 如果浏览器支持模板字符串，将会替换字符串内部的变量:
var name = '小明';
var age = 20;
----
console.log(`你好, ${name}, 你今年${age}岁了!`);
```
#### 操作字符串 
1. 字符串常见的操作如下：

```
var s = 'Hello, world!';
s.length; // 13
```
2. 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：

```
var s = 'Hello, world!';

s[0]; // 'H'
s[6]; // ' '
s[7]; // 'w'
s[12]; // '!'
s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined
```
3. None

```
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```
4. JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：

#### toUpperCase 
1. None

```
var s = 'Hello';
s.toUpperCase(); // 返回'HELLO'
```
#### toLowerCase 
1. None

```
var s = 'Hello';
var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lower
lower; // 'hello'
```
#### indexOf 
1. None

```
var s = 'hello, world';
s.indexOf('world'); // 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
```
#### substring 
1. None

```
var s = 'hello, world'
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```
## underscore
### Collections
1. underscore为集合类对象提供了一致的接口。集合类是指Array和Object，暂不支持Map和Set。

#### map/filter 
1. 和

```
'use strict';

var obj = {
    name: 'bob',
    school: 'No.1 middle school',
    address: 'xueyuan road'
};
----
var upper = _.map(obj, function (value, key) {
    return ???;
});
----
console.log(JSON.stringify(upper));
```
2. 你也许会想，为啥对Object作

#### every / some 
1. 当集合的所有元素都满足条件时，

```
'use strict';
// 所有元素都大于0？
_.every([1, 4, 7, -3, -9], (x) => x > 0); // false
// 至少一个元素大于0？
_.some([1, 4, 7, -3, -9], (x) => x > 0); // true
```
2. 当集合是Object时，我们可以同时获得value和key：

```
'use strict';
var obj = {
    name: 'bob',
    school: 'No.1 middle school',
    address: 'xueyuan road'
};
// 判断key和value是否全部是小写：
----
var r1 = _.every(obj, function (value, key) {
    return ???;
});
var r2 = _.some(obj, function (value, key) {
    return ???;
});
----
console.log('every key-value are lowercase: ' + r1 + '\nsome key-value are lowercase: ' + r2);
```
#### max / min 
1. 这两个函数直接返回集合中最大和最小的数：

```
'use strict';
var arr = [3, 5, 7, 9];
_.max(arr); // 9
_.min(arr); // 3

// 空集合会返回-Infinity和Infinity，所以要先判断集合不为空：
_.max([])
-Infinity
_.min([])
Infinity
```
2. 注意，如果集合是Object，

```
'use strict';
_.max({ a: 1, b: 2, c: 3 }); // 3
```
#### groupBy 
1. None

```
'use strict';

var scores = [20, 81, 75, 40, 91, 59, 77, 66, 72, 88, 99];
var groups = _.groupBy(scores, function (x) {
    if (x < 60) {
        return 'C';
    } else if (x < 80) {
        return 'B';
    } else {
        return 'A';
    }
});
// 结果:
// {
//   A: [81, 91, 88, 99],
//   B: [75, 77, 66, 72],
//   C: [20, 40, 59]
// }
```
2. 可见

#### shuffle / sample 
1. None

```
'use strict';
// 注意每次结果都不一样：
_.shuffle([1, 2, 3, 4, 5, 6]); // [3, 5, 4, 6, 2, 1]
```
2. None

```
'use strict';
// 注意每次结果都不一样：
// 随机选1个：
_.sample([1, 2, 3, 4, 5, 6]); // 2
// 随机选3个：
_.sample([1, 2, 3, 4, 5, 6], 3); // [6, 1, 4]
```
3. 更多完整的函数请参考underscore的文档：

### Chaining
1. 还记得jQuery支持链式调用吗？

```
$('a').attr('target', '_blank')
      .append(' <i class="uk-icon-external-link"></i>')
      .click(function () {});
```
2. 如果我们有一组操作，用underscore提供的函数，写出来像这样：

```
_.filter(_.map([1, 4, 9, 16, 25], Math.sqrt), x => x % 2 === 1);
// [1, 3, 5]
```
3. 能不能写成链式调用？

4. 能！

5. underscore提供了把对象包装成能进行链式调用的方法，就是

```
----
var r = _.chain([1, 4, 9, 16, 25])
         .map(Math.sqrt)
         .filter(x => x % 2 === 1)
         .value();
----
console.log(r); // [1, 3, 5]
```
6. 因为每一步返回的都是包装对象，所以最后一步的结果需要调用

#### 小结 
1. 通过学习underscore，是不是对JavaScript的函数式编程又有了进一步的认识？

### Arrays
1. underscore为

#### first / last 
1. 顾名思义，这两个函数分别取第一个和最后一个元素：

```
'use strict';
var arr = [2, 4, 6, 8];
_.first(arr); // 2
_.last(arr); // 8
```
#### flatten 
1. None

```
'use strict';

_.flatten([1, [2], [3, [[4], [5]]]]); // [1, 2, 3, 4, 5]
```
#### zip / unzip 
1. None

```
'use strict';

var names = ['Adam', 'Lisa', 'Bart'];
var scores = [85, 92, 59];
_.zip(names, scores);
// [['Adam', 85], ['Lisa', 92], ['Bart', 59]]
```
2. None

```
'use strict';
var namesAndScores = [['Adam', 85], ['Lisa', 92], ['Bart', 59]];
_.unzip(namesAndScores);
// [['Adam', 'Lisa', 'Bart'], [85, 92, 59]]
```
#### object 
1. 有时候你会想，与其用

```
'use strict';

var names = ['Adam', 'Lisa', 'Bart'];
var scores = [85, 92, 59];
_.object(names, scores);
// {Adam: 85, Lisa: 92, Bart: 59}
```
2. 注意

#### range 
1. None

```
'use strict';

// 从0开始小于10:
_.range(10); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

// 从1开始小于11：
_.range(1, 11); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// 从0开始小于30，步长5:
_.range(0, 30, 5); // [0, 5, 10, 15, 20, 25]

// 从0开始大于-10，步长-1:
_.range(0, -10, -1); // [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
```
2. 更多完整的函数请参考underscore的文档：

#### 练习 
1. 请根据underscore官方文档，使用

```
'use strict';

var arr = ['Apple', 'orange', 'banana', 'ORANGE', 'apple', 'PEAR'];
----
var result = ???
----
// 测试
if (result.toString() === ["Apple", "orange", "banana", "PEAR"].toString()) {
    console.log('测试成功!');
} else {
    console.log('测试失败!');
}
```
### Functions
1. 因为underscore本来就是为了充分发挥JavaScript的函数式编程特性，所以也提供了大量JavaScript本身没有的高阶函数。

#### bind 
1. None

```
'use strict';

var s = ' Hello  ';
s.trim();
// 输出'Hello'

var fn = s.trim;
fn();
// Uncaught TypeError: String.prototype.trim called on null or undefined
```
2. 如果你想用

```
'use strict';

var s = ' Hello  ';
var fn = s.trim;
// 调用call并传入s对象作为this:
fn.call(s)
// 输出Hello
```
3. 这样搞多麻烦！还不如直接用

```
'use strict';

var s = ' Hello  ';
var fn = _.bind(s.trim, s);
fn();
// 输出Hello
```
4. 结论：当用一个变量

#### partial 
1. None

2. 假设我们要计算x

3. 假设我们经常计算2

```
'use strict';

var pow2N = _.partial(Math.pow, 2);
pow2N(3); // 8
pow2N(5); // 32
pow2N(10); // 1024
```
4. 如果我们不想固定第一个参数，想固定第二个参数怎么办？比如，希望创建一个偏函数

```
'use strict';

var cube = _.partial(Math.pow, _, 3);
cube(3); // 27
cube(5); // 125
cube(10); // 1000
```
5. 可见，创建偏函数的目的是将原函数的某些参数固定住，可以降低新函数调用的难度。

#### memoize 
1. 如果一个函数调用开销很大，我们就可能希望能把结果缓存下来，以便后续调用时直接获得结果。举个例子，计算阶乘就比较耗时：

```
'use strict';

function factorial(n) {
    console.log('start calculate ' + n + '!...');
    var s = 1, i = n;
    while (i > 1) {
        s = s * i;
        i --;
    }
    console.log(n + '! = ' + s);
    return s;
}

factorial(10); // 3628800
// 注意控制台输出:
// start calculate 10!...
// 10! = 3628800
```
2. 用

```
'use strict';

var factorial = _.memoize(function(n) {
    console.log('start calculate ' + n + '!...');
    var s = 1, i = n;
    while (i > 1) {
        s = s * i;
        i --;
    }
    console.log(n + '! = ' + s);
    return s;
});

// 第一次调用:
factorial(10); // 3628800
// 注意控制台输出:
// start calculate 10!...
// 10! = 3628800

// 第二次调用:
factorial(10); // 3628800
// 控制台没有输出
```
3. 对于相同的调用，比如连续两次调用

4. 可以对

```
'use strict';

var factorial = _.memoize(function(n) {
    console.log('start calculate ' + n + '!...');
    if (n < 2) {
        return 1;
    }
    return n * factorial(n - 1);
});

factorial(10); // 3628800
// 输出结果说明factorial(1)~factorial(10)都已经缓存了:
// start calculate 10!...
// start calculate 9!...
// start calculate 8!...
// start calculate 7!...
// start calculate 6!...
// start calculate 5!...
// start calculate 4!...
// start calculate 3!...
// start calculate 2!...
// start calculate 1!...

factorial(9); // 362880
// console无输出
```
#### once 
1. 顾名思义，

```
'use strict';
----
var register = _.once(function () {
    alert('Register ok!');
});
----
// 测试效果:
register();
register();
register();
```
#### delay 
1. None

```
'use strict';

// 2秒后调用alert():
_.delay(alert, 2000);
```
2. 如果要延迟调用的函数有参数，把参数也传进去：

```
'use strict';

var log = _.bind(console.log, console);
_.delay(log, 2000, 'Hello,', 'world!');
// 2秒后打印'Hello, world!':
```
3. 更多完整的函数请参考underscore的文档：

### Objects
1. 和

#### keys / allKeys 
1. None

```
'use strict';

function Student(name, age) {
    this.name = name;
    this.age = age;
}

var xiaoming = new Student('小明', 20);
_.keys(xiaoming); // ['name', 'age']
```
2. None

```
'use strict';

function Student(name, age) {
    this.name = name;
    this.age = age;
}
Student.prototype.school = 'No.1 Middle School';
var xiaoming = new Student('小明', 20);
_.allKeys(xiaoming); // ['name', 'age', 'school']
```
#### values 
1. 和

```
'use strict';

var obj = {
    name: '小明',
    age: 20
};

_.values(obj); // ['小明', 20]
```
2. 注意，没有

#### mapObject 
1. None

```
'use strict';

var obj = { a: 1, b: 2, c: 3 };
// 注意传入的函数签名，value在前，key在后:
_.mapObject(obj, (v, k) => 100 + v); // { a: 101, b: 102, c: 103 }
```
#### invert 
1. None

```
'use strict';

var obj = {
    Adam: 90,
    Lisa: 85,
    Bart: 59
};
_.invert(obj); // { '59': 'Bart', '85': 'Lisa', '90': 'Adam' }
```
#### extend / extendOwn 
1. None

```
'use strict';

var a = {name: 'Bob', age: 20};
_.extend(a, {age: 15}, {age: 88, city: 'Beijing'}); // {name: 'Bob', age: 88, city: 'Beijing'}
// 变量a的内容也改变了：
a; // {name: 'Bob', age: 88, city: 'Beijing'}
```
2. 注意：如果有相同的key，后面的object的value将覆盖前面的object的value。

3. None

#### clone 
1. 如果我们要复制一个object对象，就可以用

```
'use strict';
var source = {
    name: '小明',
    age: 20,
    skills: ['JavaScript', 'CSS', 'HTML']
};
----
var copied = _.clone(source);
----
console.log(JSON.stringify(copied, null, '  '));
```
2. 注意，

```
source.skills === copied.skills; // true
```
3. 也就是说，修改

#### isEqual 
1. None

```
'use strict';

var o1 = { name: 'Bob', skills: { Java: 90, JavaScript: 99 }};
var o2 = { name: 'Bob', skills: { JavaScript: 99, Java: 90 }};

o1 === o2; // false
_.isEqual(o1, o2); // true
```
2. None

```
'use strict';

var o1 = ['Bob', { skills: ['Java', 'JavaScript'] }];
var o2 = ['Bob', { skills: ['Java', 'JavaScript'] }];

o1 === o2; // false
_.isEqual(o1, o2); // true
```
3. 更多完整的函数请参考underscore的文档：

## 期末总结
## Node.js
### 模块
1. 在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。

2. 为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。

3. 使用模块有什么好处？

4. 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。

5. 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。

6. 在上一节，我们编写了一个

7. 我们把

```
'use strict';

var s = 'Hello';

function greet(name) {
    console.log(s + ', ' + name + '!');
}

module.exports = greet;
```
8. 函数

9. 问题是其他模块怎么使用

```
'use strict';

// 引入hello模块:
var greet = require('./hello');

var s = 'Michael';

greet(s); // Hello, Michael!
```
10. 注意到引入

```
var greet = require('./hello');
```
11. 引入的模块作为变量保存在

12. 在使用

```
var greet = require('./hello'); // 不要忘了写相对目录!
```
13. 如果只写模块名：

```
var greet = require('hello');
```
14. 则Node会依次在内置模块、全局模块和当前模块下查找

```
module.js
    throw err;
          ^
Error: Cannot find module 'hello'
    at Function.Module._resolveFilename
    at Function.Module._load
    ...
    at Function.Module._load
    at Function.Module.runMain
```
15. 遇到这个错误，你要检查：

16. 


#### CommonJS规范 
1. 这种模块加载机制被称为CommonJS规范。在这个规范下，每个

2. 一个模块想要对外暴露变量（函数也是变量），可以用

#### 结论 
1. 要在模块中对外输出变量，用：

```
module.exports = variable;
```
2. 输出的变量可以是任意对象、函数、数组等等。

3. 要引入其他模块输出的对象，用：

```
var foo = require('other_module');
```
4. 引入的对象具体是什么，取决于引入模块输出的对象。

#### 深入了解模块原理 
1. 如果你想详细地了解CommonJS的模块实现原理，请继续往下阅读。如果不想了解，请直接跳到最后做练习。

2. 当我们编写JavaScript代码时，我们可以申明全局变量：

```
var s = 'global';
```
3. 在浏览器中，大量使用全局变量可不好。如果你在

4. 也就是说，JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。

5. 那Node.js是如何实现这一点的？

6. 其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。

7. 请注意我们编写的

```
var s = 'Hello';
var name = 'world';

console.log(s + ' ' + name + '!');
```
8. Node.js加载了

```
(function () {
    // 读取的hello.js代码:
    var s = 'Hello';
    var name = 'world';

    console.log(s + ' ' + name + '!');
    // hello.js代码结束
})();
```
9. 这样一来，原来的全局变量

10. 所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。

11. 但是，模块的输出

12. 这个也很容易实现，Node可以先准备一个对象

```
// 准备module对象:
var module = {
    id: 'hello',
    exports: {}
};
var load = function (module) {
    // 读取的hello.js代码:
    function greet(name) {
        console.log('Hello, ' + name + '!');
    }
    
    module.exports = greet;
    // hello.js代码结束
    return module.exports;
};
var exported = load(module);
// 保存module:
save(module, exported);
```
13. 可见，变量

```
module.exports = greet;
```
14. 通过把参数

15. 由于Node保存了所有导入的

```
var greet = require('./hello');
```
16. 以上是Node实现JavaScript模块的一个简单的原理介绍。

#### module.exports vs exports 
1. 很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：

2. 方法一：对module.exports赋值：

```
// hello.js

function hello() {
    console.log('Hello, world!');
}

function greet(name) {
    console.log('Hello, ' + name + '!');
}

module.exports = {
    hello: hello,
    greet: greet
};
```
3. 方法二：直接使用exports：

```
// hello.js

function hello() {
    console.log('Hello, world!');
}

function greet(name) {
    console.log('Hello, ' + name + '!');
}

function hello() {
    console.log('Hello, world!');
}

exports.hello = hello;
exports.greet = greet;
```
4. 但是你不可以直接对

```
// 代码可以执行，但是模块并没有输出任何变量:
exports = {
    hello: hello,
    greet: greet
};
```
5. 如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：

6. 首先，Node会把整个待加载的

```
var module = {
    id: 'hello',
    exports: {}
};
```
7. None

```
var load = function (exports, module) {
    // hello.js的文件内容
    ...
    // load函数返回:
    return module.exports;
};

var exported = load(module.exports, module);
```
8. 也就是说，默认情况下，Node准备的

```
exports.foo = function () { return 'foo'; };
exports.bar = function () { return 'bar'; };
```
9. 也可以写：

```
module.exports.foo = function () { return 'foo'; };
module.exports.bar = function () { return 'bar'; };
```
10. 换句话说，Node默认给你准备了一个空对象

11. 但是，如果我们要输出的是一个函数或数组，那么，只能给

```
module.exports = function () { return 'foo'; };
```
12. 给

#### 结论 
1. 如果要输出一个键值对象

2. 如果要输出一个函数或数组，必须直接对

3. 所以我们可以得出结论：直接对

```
module.exports = {
    foo: function () { return 'foo'; }
};
```
4. 或者：

```
module.exports = function () { return 'foo'; };
```
5. 最终，我们

#### 练习 
1. 编写

2. 编写

#### 参考源码 
1. None

### Web开发
1. 最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种Client/Server模式简称CS架构。

2. 随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而CS架构需要每个客户端逐个升级桌面App，因此，Browser/Server模式开始流行，简称BS架构。

3. 在BS架构下，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。

4. 当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，服务器端升级后，客户端无需任何部署就可以使用到新的版本，因此，BS架构迅速流行起来。

5. 今天，除了重量级的软件如Office，Photoshop等，大部分软件都以Web形式提供。比如，新浪提供的新闻、博客、微博等服务，均是Web应用。

6. Web应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段：

7. 静态Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的；

8. CGI：由于静态Web页面无法与用户交互，比如用户填写了一个注册表单，静态Web页面就无法处理。要处理用户发送的动态数据，出现了Common Gateway Interface，简称CGI，用C/C++编写。

9. ASP/JSP/PHP：由于Web应用特点是修改频繁，用C/C++这样的低级语言非常不适合Web开发，而脚本语言由于开发效率高，与HTML结合紧密，因此，迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。

10. MVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了Model-View-Controller的模式，来简化Web开发。ASP发展为ASP.Net，JSP和PHP也有一大堆MVC框架。

11. 目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。

12. 由于Node.js把JavaScript引入了服务器端，因此，原来必须使用PHP/Java/C#/Python/Ruby等其他语言来开发服务器端程序，现在可以使用Node.js开发了！

13. 用Node.js开发Web服务器端，有几个显著的优势：

14. 一是后端语言也是JavaScript，以前掌握了前端JavaScript的开发人员，现在可以同时编写后端代码；

15. 二是前后端统一使用JavaScript，就没有切换语言的障碍了；

16. 三是速度快，非常快！这得益于Node.js天生是异步的。

17. 在Node.js诞生后的短短几年里，出现了无数种Web框架、ORM框架、模版引擎、测试框架、自动化构建工具，数量之多，即使是JavaScript老司机，也不免眼花缭乱。

18. 常见的Web框架包括：

19. ORM框架比Web框架要少一些：

20. 模版引擎PK：

21. 测试框架包括：

22. 构建工具有：

23. 目前，在npm上已发布的开源Node.js模块数量超过了30万个。

24. 有选择恐惧症的朋友，看到这里可以洗洗睡了。

25. 好消息是这个教程已经帮你选好了，你只需要跟着教程一条道走到黑就可以了。

### 搭建Node开发环境
1. 使用文本编辑器来开发Node程序，最大的缺点是效率太低，运行Node程序还需要在命令行单独敲命令。如果还需要调试程序，就更加麻烦了。

2. 所以我们需要一个IDE集成开发环境，让我们能在一个环境里编码、运行、调试，这样就可以大大提升开发效率。

3. Java的集成开发环境有Eclipse，Intellij idea等，C#的集成开发环境有Visual Studio，那么问题又来了：Node.js的集成开发环境到底哪家强？

4. 考察Node.js的集成开发环境，重点放在启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。

5. 综合考察后，我们隆重向大家推荐Node.js集成开发环境：

#### Visual Studio Code 
1. Visual Studio Code由微软出品，但它不是那个大块头的Visual Studio，它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用。

#### 安装Visual Studio Code 
1. 可以从Visual Studio Code的

2. 安装过程中，请务必钩上以下选项：

3. None

4. None

5. 这将大大提升将来的操作快捷度。

6. 在Mac系统上，Finder选中一个目录，右键菜单并没有“通过Code打开”这个操作。不过我们可以通过Automator自己添加这个操作。

7. 先运行Automator，选择“服务”：

8. None

9. 然后，执行以下操作：

10. None

11. 


```
for f in "$@"
do
    open -a "Visual Studio Code" "$f"
done
```
12. 保存为“Open With VSCode”后，打开Finder，选中一个文件夹，点击右键，“服务”，就可以看到“Open With VSCode”菜单：

13. None

#### 运行和调试JavaScript 
1. 在VS Code中，我们可以非常方便地运行JavaScript文件。

2. VS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。此外，VS Code在工程目录下还需要一个

3. 假设我们在

```
hello/ <-- workspace dir
|
+- hello.js <-- JavaScript file
|
+- .vscode/  <-- VS Code config
   |
   +- launch.json <-- VS Code config file for JavaScript
```
4. 可以用VS Code快速创建

```
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Run hello.js",
            "type": "node",
            "request": "launch",
            "program": "${workspaceRoot}/hello.js",
            "stopOnEntry": false,
            "args": [],
            "cwd": "${workspaceRoot}",
            "preLaunchTask": null,
            "runtimeExecutable": null,
            "runtimeArgs": [
                "--nolazy"
            ],
            "env": {
                "NODE_ENV": "development"
            },
            "externalConsole": false,
            "sourceMaps": false,
            "outDir": null
        }
    ]
}
```
5. 有了配置文件，即可使用VS Code调试JavaScript。

6. 视频演示：

7. None

#### 参考源码 
1. None

### 自动化工具
1. 即将推出，请耐心等待。等待不耐烦的，请关注微博

2. 
window.hurry = true;


### 基本模块
1. 因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。

#### global 
1. 在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫

```
> global.console
Console {
  log: [Function: bound ],
  info: [Function: bound ],
  warn: [Function: bound ],
  error: [Function: bound ],
  dir: [Function: bound ],
  time: [Function: bound ],
  timeEnd: [Function: bound ],
  trace: [Function: bound trace],
  assert: [Function: bound ],
  Console: [Function: Console] }
```
#### process 
1. None

```
> process === global.process;
true
> process.version;
'v5.2.0'
> process.platform;
'darwin'
> process.arch;
'x64'
> process.cwd(); //返回当前工作目录
'/Users/michael'
> process.chdir('/private/tmp'); // 切换当前工作目录
undefined
> process.cwd();
'/private/tmp'
```
2. JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。

3. 如果我们想要在下一次事件响应中执行代码，可以调用

```
// test.js

// process.nextTick()将在下一轮事件循环中调用:
process.nextTick(function () {
    console.log('nextTick callback!');
});
console.log('nextTick was set!');
```
4. 用Node执行上面的代码

```
nextTick was set!
nextTick callback!
```
5. 这说明传入

6. Node.js进程本身的事件就由

```
// 程序即将退出时的回调函数:
process.on('exit', function (code) {
    console.log('about to exit with code: ' + code);
});
```
#### 判断JavaScript执行环境 
1. 有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：

```
if (typeof(window) === 'undefined') {
    console.log('node.js');
} else {
    console.log('browser');
}
```
2. 后面，我们将介绍Node.js的常用内置模块。

#### 参考源码 
1. None

### 第一个Node程序
1. 在前面的所有章节中，我们编写的JavaScript代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。

2. 从本章开始，我们编写的JavaScript代码将

3. 那么问题来了：文本编辑器到底哪家强？

4. 首先，请注意，

5. 所以，用记事本写代码时请注意，保存文件时使用ANSI编码，并且暂时不要输入中文。

6. 如果你的电脑上已经安装了

7. 输入以下代码：

```
'use strict';

console.log('Hello, world.');
```
8. 第一行总是写上

9. 然后，选择一个目录，例如

```
C:\Workspace>node hello.js
Hello, world.
```
10. 也可以保存为别的名字，比如

11. 如果当前目录下没有

```
C:\Workspace>node hello.js
module.js:338
    throw err;
          ^
Error: Cannot find module 'C:\Workspace\hello.js'
    at Function.Module._resolveFilename
    at Function.Module._load
    at Function.Module.runMain
    at startup
    at node.js
```
12. 报错的意思就是，没有找到

#### 命令行模式和Node交互模式 
1. 请注意区分命令行模式和Node交互模式。

2. 看到类似

3. None

4. 在命令行模式下，可以执行

5. 看到

6. None

7. 在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。

8. 此外，在命令行模式运行

9. 例如，在Node交互式环境下，输入：

```
> 100 + 200 + 300;
600
```
10. 直接可以看到结果

11. 但是，写一个

```
100 + 200 + 300;
```
12. 然后在命令行模式下执行：

```
C:\Workspace>node calc.js
```
13. 发现什么输出都没有。

14. 这是正常的。想要输出结果，必须自己用

```
console.log(100 + 200 + 300);
```
15. 再执行，就可以看到结果：

```
C:\Workspace>node calc.js
600
```
#### 使用严格模式 
1. 如果在JavaScript文件开头写上

```
node --use_strict calc.js
```
2. 后续代码，如无特殊说明，我们都会直接给Node传递

#### 小结 
1. 用文本编辑器写JavaScript程序，然后保存为后缀为

2. Node的交互模式和直接运行

3. 直接输入

4. 直接运行

5. 在编写JavaScript代码的时候，完全可以一边在文本编辑器里写代码，一边开一个Node交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27'的超大显示器！

#### 参考源码 
1. None

### 安装Node.js和npm
1. 由于Node.js平台是在后端运行JavaScript代码，所以，必须首先在本机安装Node环境。

#### 安装Node.js 
1. 目前Node.js的最新版本是7.6.x。首先，从

2. 在Windows上安装时务必选择全部组件，包括勾选

3. 安装完成后，在Windows环境下，请打开命令提示符，然后输入

```
C:\Users\IEUser>node -v
v7.6.0
```
4. 继续在命令提示符输入

5. 要退出Node.js环境，连按两次Ctrl+C。

6. 


7. 在Mac或Linux环境下，请打开终端，然后输入

```
$ node -v
v7.6.0
```
8. 如果版本号小于

#### npm 
1. 在正式开始Node.js学习之前，我们先认识一下npm。

2. npm是什么东东？npm其实是Node.js的包管理工具（package manager）。

3. 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。

4. 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。

5. 讲了这么多，npm究竟在哪？

6. 其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入

```
C:\>npm -v
4.1.2
```
7. 如果直接输入

```
C:\> npm

Usage: npm <command>

where <command> is one of:
    ...
```
8. 上面的一大堆文字告诉你，

#### 小结 
1. 请在本机安装Node.js环境，并确保

## jQuery
### 扩展
1. 当我们使用jQuery对象的方法时，由于jQuery对象可以操作一组DOM，而且支持链式操作，所以用起来非常方便。

2. 但是jQuery内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些DOM元素，用jQuery可以这么实现：

```
$('span.hl').css('backgroundColor', '#fffceb').css('color', '#d85030');

$('p a.hl').css('backgroundColor', '#fffceb').css('color', '#d85030');
```
3. 总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个

```
$('span.hl').highlight();

$('p a.hl').highlight();
```
4. 答案是肯定的。我们可以扩展jQuery来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写jQuery插件。

#### 编写jQuery插件 
1. 给jQuery对象绑定一个新方法是通过扩展

2. 
$.fn.highlight1 = function () {
    this.css('backgroundColor', '#fffceb').css('color', '#d85030');
    return this;
}


```
$.fn.highlight1 = function () {
    // this已绑定为当前jQuery对象:
    this.css('backgroundColor', '#fffceb').css('color', '#d85030');
    return this;
}
```
3. 注意到函数内部的

4. 对于如下的HTML结构：

```
<!-- HTML结构 -->
<div id="test-highlight1">
    <p>什么是<span>jQuery</span></p>
    <p><span>jQuery</span>是目前最流行的<span>JavaScript</span>库。</p>
</div>
```
5. 来测试一下

```
'use strict';
----
$('#test-highlight1 span').highlight1();
```
6. 
    

7. 细心的童鞋可能发现了，为什么最后要

```
$('span.hl').highlight1().slideDown();
```
8. 不然，用户调用的时候，就不得不把上面的代码拆成两行。

9. 但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办？

10. 我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的

11. 
$.fn.highlight2 = function (options) {
    var bgcolor = options && options.backgroundColor || '#fffceb';
    var color = options && options.color || '#d85030';
    this.css('backgroundColor', bgcolor).css('color', color);
    return this;
}


```
$.fn.highlight2 = function (options) {
    // 要考虑到各种情况:
    // options为undefined
    // options只有部分key
    var bgcolor = options && options.backgroundColor || '#fffceb';
    var color = options && options.color || '#d85030';
    this.css('backgroundColor', bgcolor).css('color', color);
    return this;
}
```
12. 对于如下HTML结构：

```
<!-- HTML结构 -->
<div id="test-highlight2">
    <p>什么是<span>jQuery</span> <span>Plugin</span></p>
    <p>编写<span>jQuery</span> <span>Plugin</span>可以用来扩展<span>jQuery</span>的功能。</p>
</div>
```
13. 来实测一下带参数的

```
'use strict';
----
$('#test-highlight2 span').highlight2({
    backgroundColor: '#00a8e6',
    color: '#ffffff'
});
```
14. 
    

15. 对于默认值的处理，我们用了一个简单的

16. 另一种方法是使用jQuery提供的辅助方法

```
// 把默认值和用户传入的options合并到对象{}中并返回:
var opts = $.extend({}, {
    backgroundColor: '#00a8e6',
    color: '#ffffff'
}, options);
```
17. 紧接着用户对

18. 也就是说，我们设定的默认值应该能允许用户修改。

19. 那默认值放哪比较合适？放全局变量肯定不合适，最佳地点是

20. 于是最终版的

21. 
$.fn.highlight = function (options) {
    var opts = $.extend({}, $.fn.highlight.defaults, options);
    this.css('backgroundColor', opts.backgroundColor).css('color', opts.color);
    return this;
}

$.fn.highlight.defaults = {
    color: '#d85030',
    backgroundColor: '#fff8de'
}


```
$.fn.highlight = function (options) {
    // 合并默认值和用户设定值:
    var opts = $.extend({}, $.fn.highlight.defaults, options);
    this.css('backgroundColor', opts.backgroundColor).css('color', opts.color);
    return this;
}

// 设定默认值:
$.fn.highlight.defaults = {
    color: '#d85030',
    backgroundColor: '#fff8de'
}
```
22. 这次用户终于满意了。用户使用时，只需一次性设定默认值：

```
$.fn.highlight.defaults.color = '#fff';
$.fn.highlight.defaults.backgroundColor = '#000';
```
23. 然后就可以非常简单地调用

24. 对如下的HTML结构：

```
<!-- HTML结构 -->
<div id="test-highlight">
    <p>如何编写<span>jQuery</span> <span>Plugin</span></p>
    <p>编写<span>jQuery</span> <span>Plugin</span>，要设置<span>默认值</span>，并允许用户修改<span>默认值</span>，或者运行时传入<span>其他值</span>。</p>
</div>
```
25. 实测一下修改默认值的效果：

```
'use strict';
----
$.fn.highlight.defaults.color = '#659f13';
$.fn.highlight.defaults.backgroundColor = '#f2fae3';

$('#test-highlight p:first-child span').highlight();

$('#test-highlight p:last-child span').highlight({
    color: '#dd1144'
});
```
26. 
    

27. 最终，我们得出编写一个jQuery插件的原则：

28. 


#### 针对特定元素的扩展 
1. 我们知道jQuery对象的有些方法只能作用在特定DOM元素上，比如

2. 还记得jQuery的选择器支持

3. 举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做？

4. 先写出用户调用的代码：

```
$('#main a').external();
```
5. 然后按照上面的方法编写一个

6. 
$.fn.external = function () {
    return this.filter('a').each(function () {
        var a = $(this);
        var url = a.attr('href');
        if (url && (url.indexOf('http://')===0 || url.indexOf('https://')===0)) {
            a.attr('href', '#0')
             .removeAttr('target')
             .append(' <i class="uk-icon-external-link"></i>')
             .click(function () {
                if(confirm('你确定要前往' + url + '？')) {
                    window.open(url);
                }
            });
        }
    });
}


```
$.fn.external = function () {
    // return返回的each()返回结果，支持链式调用:
    return this.filter('a').each(function () {
        // 注意: each()内部的回调函数的this绑定为DOM本身!
        var a = $(this);
        var url = a.attr('href');
        if (url && (url.indexOf('http://')===0 || url.indexOf('https://')===0)) {
            a.attr('href', '#0')
             .removeAttr('target')
             .append(' <i class="uk-icon-external-link"></i>')
             .click(function () {
                if(confirm('你确定要前往' + url + '？')) {
                    window.open(url);
                }
            });
        }
    });
}
```
7. 对如下的HTML结构：

```
<!-- HTML结构 -->
<div id="test-external">
    <p>如何学习<a href="http://jquery.com">jQuery</a>？</p>
    <p>首先，你要学习<a href="/wiki/1022910821149312">JavaScript</a>，并了解基本的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML">HTML</a>。</p>
</div>
```
8. 实测外链效果：

```
'use strict';
----
$('#test-external a').external();
```
9. 


#### 小结 
1. 扩展jQuery对象的功能十分简单，但是我们要遵循jQuery的原则，编写的扩展方法能支持链式调用、具备默认值和过滤特定元素，使得扩展方法看上去和jQuery本身的方法没有什么区别。

### 事件
1. 因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。

2. 浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。

3. 由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。

4. 举个例子，假设要在用户点击了超链接时弹出提示框，我们用jQuery这样绑定一个

5. 
$(function () {
    $('#test-link').click(function () {
        alert('Hello!');
    });
});


```
/* HTML:
 *
 * <a id="test-link" href="#0">点我试试</a>
 *
 */

// 获取超链接的jQuery对象:
var a = $('#test-link');
a.on('click', function () {
    alert('Hello!');
});
```
6. 实测：

7. None

8. 另一种更简化的写法是直接调用

```
a.click(function () {
    alert('Hello!');
});
```
9. 两者完全等价。我们通常用后面的写法。

10. jQuery能够绑定的事件主要包括：

#### 鼠标事件 
1. 


#### 键盘事件 
1. 键盘事件仅作用在当前焦点的DOM上，通常是

2. 


#### 其他事件 
1. 


2. 其中，

```
<html>
<head>
    <script>
        // 代码有误:
        $('#testForm).on('submit', function () {
            alert('submit!');
        });
    </script>
</head>
<body>
    <form id="testForm">
        ...
    </form>
</body>
```
3. 因为JavaScript在此执行的时候，

4. 所以我们自己的初始化代码必须放到

```
<html>
<head>
    <script>
        $(document).on('ready', function () {
            $('#testForm).on('submit', function () {
                alert('submit!');
            });
        });
    </script>
</head>
<body>
    <form id="testForm">
        ...
    </form>
</body>
```
5. 这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。

6. 由于

```
$(document).ready(function () {
    // on('submit', function)也可以简化:
    $('#testForm).submit(function () {
        alert('submit!');
    });
});
```
7. 甚至还可以再简化为：

```
$(function () {
    // init...
});
```
8. 上面的这种写法最为常见。如果你遇到

9. 完全可以反复绑定事件处理函数，它们会依次执行：

```
$(function () {
    console.log('init A...');
});
$(function () {
    console.log('init B...');
});
$(function () {
    console.log('init C...');
});
```
#### 事件参数 
1. 有些事件，如

```
$(function () {
    $('#testMouseMoveDiv').mousemove(function (e) {
        $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY);
    });
});
```
2. 
$(function () {
    $('#testMouseMoveDiv').mousemove(function (e) {
        $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY);
    });
});


3. 效果实测：

4. mousemove: 

5. 在此区域移动鼠标试试

#### 取消绑定 
1. 一个已被绑定的事件可以解除绑定，通过

```
function hello() {
    alert('hello!');
}

a.click(hello); // 绑定事件

// 10秒钟后解除绑定:
setTimeout(function () {
    a.off('click', hello);
}, 10000);
```
2. 需要特别注意的是，下面这种写法是无效的：

```
// 绑定事件:
a.click(function () {
    alert('hello!');
});

// 解除绑定:
a.off('click', function () {
    alert('hello!');
});
```
3. 这是因为两个匿名函数虽然长得一模一样，但是它们是两个

4. 为了实现移除效果，可以使用

5. 同理，无参数调用

#### 事件触发条件 
1. 一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动：

```
var input = $('#test-input');
input.change(function () {
    console.log('changed...');
});
```
2. 当用户在文本框中输入时，就会触发

```
var input = $('#test-input');
input.val('change it!'); // 无法触发change事件
```
3. 有些时候，我们希望用代码触发

```
var input = $('#test-input');
input.val('change it!');
input.change(); // 触发change事件
```
4. None

5. 为什么我们希望手动触发一个事件呢？如果不这么做，很多时候，我们就得写两份一模一样的代码。

#### 浏览器安全限制 
1. 在浏览器中，有些JavaScript代码只有在用户触发下才能执行，例如，

```
// 无法弹出新窗口，将被浏览器屏蔽:
$(function () {
    window.open('/');
});
```
2. 这些“敏感代码”只能由用户操作来触发：

```
var button1 = $('#testPopupButton1');
var button2 = $('#testPopupButton2');

function popupTestWindow() {
    window.open('/');
}

button1.click(function () {
    popupTestWindow();
});

button2.click(function () {
    // 不立刻执行popupTestWindow()，3秒后执行:
    setTimeout(popupTestWindow, 3000);
});
```
3. 当用户点击

4. 
$(function () {
    var button1 = $('#testPopupButton1');
    var button2 = $('#testPopupButton2');

    function popupTestWindow() {
        window.open('?t=' + new Date().getTime(), 'popupWindow', 'width=400&height=300');
    }

    button1.click(function () {
        popupTestWindow();
    });

    button2.click(function () {
        setTimeout(popupTestWindow, 3000);
    });
});


5. 效果实测：

6. None

#### 练习 
1. 对如下的Form表单：

```
<!-- HTML结构 -->
<form id="test-form" action="test">
    <legend>请选择想要学习的编程语言：</legend>
    <fieldset>
        <p><label class="selectAll"><input type="checkbox"> <span class="selectAll">全选</span><span class="deselectAll">全不选</span></label> <a href="#0" class="invertSelect">反选</a></p>
        <p><label><input type="checkbox" name="lang" value="javascript"> JavaScript</label></p>
        <p><label><input type="checkbox" name="lang" value="python"> Python</label></p>
        <p><label><input type="checkbox" name="lang" value="ruby"> Ruby</label></p>
        <p><label><input type="checkbox" name="lang" value="haskell"> Haskell</label></p>
        <p><label><input type="checkbox" name="lang" value="scheme"> Scheme</label></p>
		<p><button type="submit">Submit</button></p>
    </fieldset>
</form>
```
2. 绑定合适的事件处理函数，实现以下逻辑：

3. 当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选”；

4. 当用户去掉“全不选”时，自动不选中所有语言；

5. 当用户点击“反选”时，自动把所有语言状态反转（选中的变为未选，未选的变为选中）；

6. 当用户把所有语言都手动勾上时，“全选”被自动勾上，并变为“全不选”；

7. 当用户手动去掉选中至少一种语言时，“全不选”自动被去掉选中，并变为“全选”。

```
'use strict';

var
    form = $('#test-form'),
    langs = form.find('[name=lang]'),
    selectAll = form.find('label.selectAll :checkbox'),
    selectAllLabel = form.find('label.selectAll span.selectAll'),
    deselectAllLabel = form.find('label.selectAll span.deselectAll'),
    invertSelect = form.find('a.invertSelect');

// 重置初始化状态:
form.find('*').show().off();
form.find(':checkbox').prop('checked', false).off();
deselectAllLabel.hide();
// 拦截form提交事件:
form.off().submit(function (e) {
    e.preventDefault();
    alert(form.serialize());
});
----
// TODO:绑定事件
----
// 测试:
console.log('请测试功能是否正常。');
```
8. 
    

### 选择器
1. 选择器是jQuery的核心。一个选择器写出来类似

2. 为什么jQuery要发明选择器？回顾一下DOM操作中我们经常使用的代码：

```
// 按ID查找：
var a = document.getElementById('dom-id');

// 按tag查找：
var divs = document.getElementsByTagName('div');

// 查找<p class="red">：
var ps = document.getElementsByTagName('p');
// 过滤出class="red":
// TODO:

// 查找<table class="green">里面的所有<tr>：
var table = ...
for (var i=0; i<table.children; i++) {
    // TODO: 过滤出<tr>
}
```
3. 这些代码实在太繁琐了，并且，在层级关系中，例如，查找

```
<table>
    <tbody>
        <tr>...</tr>
        <tr>...</tr>
    </tbody>
</table>
```
4. 很多时候，需要递归查找所有子节点。

5. jQuery的选择器就是帮助我们快速定位到一个或多个DOM节点。

#### 按ID查找 
1. 如果某个DOM节点有

```
// 查找<div id="abc">:
var div = $('#abc');
```
2. None

3. 什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。

4. 以上面的查找为例，如果

```
[<div id="abc">...</div>]
```
5. 如果

```
[]
```
6. 总之jQuery的选择器不会返回

7. jQuery对象和DOM对象之间可以互相转化：

```
var div = $('#abc'); // jQuery对象
var divDom = div.get(0); // 假设存在div，获取第1个DOM元素
var another = $(divDom); // 重新把DOM包装为jQuery对象
```
8. 通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用

#### 按tag查找 
1. 按tag查找只需要写上tag名称就可以了：

```
var ps = $('p'); // 返回所有<p>节点
ps.length; // 数一数页面有多少个<p>节点
```
#### 按class查找 
1. 按class查找注意在class名称前加一个

```
var a = $('.red'); // 所有节点包含`class="red"`都将返回
// 例如:
// <div class="red">...</div>
// <p class="green red">...</p>
```
2. 通常很多节点有多个class，我们可以查找同时包含

```
var a = $('.red.green'); // 注意没有空格！
// 符合条件的节点：
// <div class="red green">...</div>
// <div class="blue green red">...</div>
```
#### 按属性查找 
1. 一个DOM节点除了

```
var email = $('[name=email]'); // 找出<??? name="email">
var passwordInput = $('[type=password]'); // 找出<??? type="password">
var a = $('[items="A B"]'); // 找出<??? items="A B">
```
2. 当属性的值包含空格等特殊字符时，需要用双引号括起来。

3. 按属性查找还可以使用前缀查找或者后缀查找：

```
var icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的DOM
// 例如: name="icon-1", name="icon-2"
var names = $('[name$=with]'); // 找出所有name属性值以with结尾的DOM
// 例如: name="startswith", name="endswith"
```
4. 这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响：

```
var icons = $('[class^="icon-"]'); // 找出所有class包含至少一个以`icon-`开头的DOM
// 例如: class="icon-clock", class="abc icon-home"
```
#### 组合查找 
1. 组合查找就是把上述简单选择器组合起来使用。如果我们查找

```
var emailInput = $('input[name=email]'); // 不会找出<div name="email">
```
2. 同样的，根据tag和class来组合查找也很常见：

```
var tr = $('tr.red'); // 找出<tr class="red ...">...</tr>
```
#### 多项选择器 
1. 多项选择器就是把多个选择器用

```
$('p,div'); // 把<p>和<div>都选出来
$('p.red,p.green'); // 把<p class="red">和<p class="green">都选出来
```
2. 要注意的是，选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素。例如，

#### 练习 
1. 使用jQuery选择器分别选出指定元素：

2. 


```
<!-- HTML结构 -->
<div id="test-jquery">
    <p id="para-1" class="color-red">JavaScript</p>
    <p id="para-2" class="color-green">Haskell</p>
    <p class="color-red color-green">Erlang</p>
    <p name="name" class="color-black">Python</p>
    <form class="test-form" target="_blank" action="#0" onsubmit="return false;">
        <legend>注册新用户</legend>
        <fieldset>
            <p><label>名字: <input name="name"></label></p>
            <p><label>邮件: <input name="email"></label></p>
            <p><label>口令: <input name="password" type="password"></label></p>
            <p><button type="submit">注册</button></p>
        </fieldset>
    </form>
</div>
```
3. 运行查看结果：

```
'use strict';

var selected = null;
----
selected = ???;
----
// 高亮结果:
if (!(selected instanceof jQuery)) {
    return console.log('不是有效的jQuery对象!');
}
$('#test-jquery').find('*').css('background-color', '');
selected.css('background-color', '#ffd351');
```
### 动画
1. 用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。

2. 但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。

3. 使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！

4. 让我们先来看看jQuery内置的几种动画样式：

#### show / hide 
1. 直接以无参数形式调用

```
var div = $('#test-show-hide');
div.hide(3000); // 在3秒钟内逐渐消失
```
2. 时间以毫秒为单位，但也可以是

```
var div = $('#test-show-hide');
div.show('slow'); // 在0.6秒钟内逐渐显示
```
3. None

4. 效果实测：

5. 
    

#### slideUp / slideDown 
1. 你可能已经看出来了，

2. None

```
var div = $('#test-slide');
div.slideUp(3000); // 在3秒钟内逐渐向上消失
```
3. 效果实测：

4. 
    

#### fadeIn / fadeOut 
1. None

```
var div = $('#test-fade');
div.fadeOut('slow'); // 在0.6秒内淡出
```
2. 
    

#### 自定义动画 
1. 如果上述动画效果还不能满足你的要求，那就祭出最后大招：

```
var div = $('#test-animate');
div.animate({
    opacity: 0.25,
    width: '256px',
    height: '256px'
}, 3000); // 在3秒钟内CSS过渡到设定值
```
2. None

```
var div = $('#test-animate');
div.animate({
    opacity: 0.25,
    width: '256px',
    height: '256px'
}, 3000, function () {
    console.log('动画已结束');
    // 恢复至初始状态:
    $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');
});
```
3. 实际上这个回调函数参数对于基本动画也是适用的。

4. 有了

5. 
function customAnimate() {
    $('#test-animate').animate({
        opacity: 0.25,
        width: '256px',
        height: '256px'
    }, 3000, function() {
        $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');
    });
}


6. 
    

#### 串行动画 
1. jQuery的动画效果还可以串行执行，通过

```
var div = $('#test-animates');
// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小
div.slideDown(2000)
   .delay(1000)
   .animate({
       width: '256px',
       height: '256px'
   }, 2000)
   .delay(1000)
   .animate({
       width: '128px',
       height: '128px'
   }, 2000);
}
</script>
```
2. 因为动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作。简单地把动画封装在函数中是不够的。

3. 效果实测：

4. 
function animates() {
    $('#test-animates')
        .hide()
        .slideDown(2000)
        .delay(1000)
        .animate({
            width: '256px',
            height: '256px'
        }, 2000)
        .delay(1000)
        .animate({
            width: '128px',
            height: '128px'
        }, 2000);
}


5. 
    

#### 为什么有的动画没有效果 
1. 你可能会遇到，有的动画如

2. 此外，jQuery也没有实现对

#### 练习 
1. 在执行删除操作时，给用户显示一个动画比直接调用

```
'use strict';

function deleteFirstTR() {
    var tr = $('#test-table>tbody>tr:visible').first();
----
----
}

deleteFirstTR();
```
2. 
$(function () {
    var trs = [['Bart Simpson', 'bart.s@primary.school', 'Springfield', 'Active'],
               ['Michael Scofield', 'm.scofield@escape.org', 'Fox River', 'Locked'],
               ['Optimus Prime', 'prime@cybertron.org', 'Cybertron', 'Active'],
               ['Peter Parker', 'spider@movie.org', 'New York', 'Active'],
               ['Thor Odinson', 'thor@asgard.org', 'Asgard', 'Active']];
    var tbody = $('#test-table>tbody');
    var i;
    for (i=0; i < trs.length; i++) {
        tbody.append('<tr><td>' + trs[i].join('</td><td>') + '</td></tr>');
    }
    i = 0;
    $('#test-add-button').click(function () {
        if (i>=trs.length) {
            i = 0;
        }
        tbody.append('<tr><td>' + trs[i].join('</td><td>') + '</td></tr>');
        i ++;
    });
});


3. 
    

4. None

### 操作DOM
1. jQuery的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了jQuery对象，到底要干什么？

2. 答案当然是操作对应的DOM节点啦！

3. 回顾一下修改DOM的CSS、文本、设置HTML有多么麻烦，而且有的浏览器只有innerHTML，有的浏览器支持innerText，有了jQuery对象，不需要考虑浏览器差异了，全部统一操作！

#### 修改Text和HTML 
1. jQuery对象的

```
<!-- HTML结构 -->
<ul id="test-ul">
    <li class="js">JavaScript</li>
    <li name="book">Java &amp; JavaScript</li>
</ul>
```
2. 分别获取文本和HTML：

```
$('#test-ul li[name=book]').text(); // 'Java & JavaScript'
$('#test-ul li[name=book]').html(); // 'Java &amp; JavaScript'
```
3. 如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用

```
'use strict';
var j1 = $('#test-ul li.js');
var j2 = $('#test-ul li[name=book]');
----
j1.html('<span style="color: red">JavaScript</span>');
j2.text('JavaScript & ECMAScript');
```
4. 
    

5. 一个jQuery对象可以包含0个或任意个DOM对象，它的方法实际上会作用在对应的每个DOM节点上。在上面的例子中试试：

```
$('#test-ul li').text('JS'); // 是不是两个节点都变成了JS？
```
6. 所以jQuery对象的另一个好处是我们可以执行一个操作，作用在对应的一组DOM节点上。即使选择器没有返回任何DOM节点，调用jQuery对象的方法仍然不会报错：

```
// 如果不存在id为not-exist的节点：
$('#not-exist').text('Hello'); // 代码不报错，没有节点被设置为'Hello'
```
7. 这意味着jQuery帮你免去了许多

#### 修改CSS 
1. jQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构：

```
<!-- HTML结构 -->
<ul id="test-css">
    <li class="lang dy"><span>JavaScript</span></li>
    <li class="lang"><span>Java</span></li>
    <li class="lang dy"><span>Python</span></li>
    <li class="lang"><span>Swift</span></li>
    <li class="lang dy"><span>Scheme</span></li>
</ul>
```
2. 要高亮显示动态语言，调用jQuery对象的

```
'use strict';
----
$('#test-css li.dy>span').css('background-color', '#ffd351').css('color', 'red');
```
3. 
    

4. None

5. jQuery对象的

```
var div = $('#test-div');
div.css('color'); // '#000033', 获取CSS属性
div.css('color', '#336699'); // 设置CSS属性
div.css('color', ''); // 清除CSS属性
```
6. 为了和JavaScript保持一致，CSS属性可以用

7. None

```
var div = $('#test-div');
div.hasClass('highlight'); // false， class是否包含highlight
div.addClass('highlight'); // 添加highlight这个class
div.removeClass('highlight'); // 删除highlight这个class
```
8. 练习：分别用

```
<!-- HTML结构 -->
<style>
.highlight {
    color: #dd1144;
    background-color: #ffd351;
}
</style>

<div id="test-highlight-css">
    <ul>
        <li class="py"><span>Python</span></li>
        <li class="js"><span>JavaScript</span></li>
        <li class="sw"><span>Swift</span></li>
        <li class="hk"><span>Haskell</span></li>
    </ul>
</div>
```
```
'use strict';
----
var div = $('#test-highlight-css');
// TODO:
```
9. 
.highlight {
    color: #dd1144;
    background-color: #ffd351;
}


10. 
    

#### 显示和隐藏DOM 
1. 要隐藏一个DOM，我们可以设置CSS的

2. 考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供

```
var a = $('a[target=_blank]');
a.hide(); // 隐藏
a.show(); // 显示
```
3. None

#### 获取DOM信息 
1. 利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码：

```
// 浏览器可视窗口大小:
$(window).width(); // 800
$(window).height(); // 600

// HTML文档大小:
$(document).width(); // 800
$(document).height(); // 3500

// 某个div的大小:
var div = $('#test-div');
div.width(); // 600
div.height(); // 300
div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效
div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效
```
2. None

```
// <div id="test-div" name="Test" start="1">...</div>
var div = $('#test-div');
div.attr('data'); // undefined, 属性不存在
div.attr('name'); // 'Test'
div.attr('name', 'Hello'); // div的name属性变为'Hello'
div.removeAttr('name'); // 删除name属性
div.attr('name'); // undefined
```
3. None

```
<input id="test-radio" type="radio" name="test" checked value="1">
```
4. 等价于：

```
<input id="test-radio" type="radio" name="test" checked="checked" value="1">
```
5. None

```
var radio = $('#test-radio');
radio.attr('checked'); // 'checked'
radio.prop('checked'); // true
```
6. None

```
var radio = $('#test-radio');
radio.is(':checked'); // true
```
7. 类似的属性还有

#### 操作表单 
1. 对于表单元素，jQuery对象统一提供

```
/*
    <input id="test-input" name="email" value="">
    <select id="test-select" name="city">
        <option value="BJ" selected>Beijing</option>
        <option value="SH">Shanghai</option>
        <option value="SZ">Shenzhen</option>
    </select>
    <textarea id="test-textarea">Hello</textarea>
*/
var
    input = $('#test-input'),
    select = $('#test-select'),
    textarea = $('#test-textarea');

input.val(); // 'test'
input.val('abc@example.com'); // 文本框的内容已变为abc@example.com

select.val(); // 'BJ'
select.val('SH'); // 选择框已变为Shanghai

textarea.val(); // 'Hello'
textarea.val('Hi'); // 文本区域已更新为'Hi'
```
2. 可见，一个

### AJAX
1. 用JavaScript写AJAX前面已经介绍过了，主要问题就是不同浏览器需要写不同代码，并且状态和错误处理写起来很麻烦。

2. 用jQuery的相关对象来处理AJAX，不但不需要考虑浏览器问题，代码也能大大简化。

#### ajax 
1. jQuery在全局对象

2. 


3. 下面的例子发送一个GET请求，并返回一个JSON格式的数据：

```
var jqxhr = $.ajax('/api/categories', {
    dataType: 'json'
});
// 请求已经发送了
```
4. 不过，如何用回调函数处理返回的数据和出错时的响应呢？

5. 还记得Promise对象吗？jQuery的jqXHR对象类似一个Promise对象，我们可以用链式写法来处理各种回调：

```
'use strict';

function ajaxLog(s) {
    var txt = $('#test-response-text');
    txt.val(txt.val() + '\n' + s);
}

$('#test-response-text').val('');
----
var jqxhr = $.ajax('/api/categories', {
    dataType: 'json'
}).done(function (data) {
    ajaxLog('成功, 收到的数据: ' + JSON.stringify(data));
}).fail(function (xhr, status) {
    ajaxLog('失败: ' + xhr.status + ', 原因: ' + status);
}).always(function () {
    ajaxLog('请求完成: 无论成功或失败都会调用');
});
```
6. 
响应结果：


#### get 
1. 对常用的AJAX操作，jQuery提供了一些辅助方法。由于GET请求最常见，所以jQuery提供了

```
var jqxhr = $.get('/path/to/resource', {
    name: 'Bob Lee',
    check: 1
});
```
2. 第二个参数如果是object，jQuery自动把它变成query string然后加到URL后面，实际的URL是：

```
/path/to/resource?name=Bob%20Lee&check=1
```
3. 这样我们就不用关心如何用URL编码并构造一个query string了。

#### post 
1. None

```
var jqxhr = $.post('/path/to/resource', {
    name: 'Bob Lee',
    check: 1
});
```
2. 实际构造的数据

#### getJSON 
1. 由于JSON用得越来越普遍，所以jQuery也提供了

```
var jqxhr = $.getJSON('/path/to/resource', {
    name: 'Bob Lee',
    check: 1
}).done(function (data) {
    // data已经被解析为JSON对象了
});
```
#### 安全限制 
1. jQuery的AJAX完全封装的是JavaScript的AJAX操作，所以它的安全限制和前面讲的用JavaScript写AJAX完全一样。

2. 如果需要使用JSONP，可以在

3. 关于跨域的设置请参考

## 浏览器
### Canvas
1. Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。

2. 没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。

3. 一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：

```
<canvas id="test-canvas" width="300" height="200"></canvas>
```
4. 由于浏览器对HTML5标准支持不一致，所以，通常在

```
<canvas id="test-stock" width="300" height="200">
    <p>Current Price: 25.51</p>
</canvas>
```
5. 在使用Canvas前，用

```
<!-- HTML代码 -->
<canvas id="test-canvas" width="200" heigth="100">
    <p>你的浏览器不支持Canvas</p>
</canvas>
```
6. 
    

```
'use strict';
----
var canvas = document.getElementById('test-canvas');
if (canvas.getContext) {
    console.log('你的浏览器支持Canvas!');
} else {
    console.log('你的浏览器不支持Canvas!');
}
```
7. None

```
var ctx = canvas.getContext('2d');
```
8. 如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：

```
gl = canvas.getContext("webgl");
```
9. 本节我们只专注于绘制2D图形。

#### 绘制形状 
1. 我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统：

2. None

3. Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。

4. None

```
'use strict';

var
    canvas = document.getElementById('test-shape-canvas'),
    ctx = canvas.getContext('2d');
----
ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
ctx.fillStyle = '#dddddd'; // 设置颜色
ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色
// 利用Path绘制复杂路径:
var path=new Path2D();
path.arc(75, 75, 50, 0, Math.PI*2, true);
path.moveTo(110,75);
path.arc(75, 75, 35, 0, Math.PI, false);
path.moveTo(65, 65);
path.arc(60, 65, 5, 0, Math.PI*2, true);
path.moveTo(95, 65);
path.arc(90, 65, 5, 0, Math.PI*2, true);
ctx.strokeStyle = '#0000ff';
ctx.stroke(path);
```
5. 


#### 绘制文本 
1. 绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：

```
'use strict';

var
    canvas = document.getElementById('test-text-canvas'),
    ctx = canvas.getContext('2d');
----
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.shadowOffsetX = 2;
ctx.shadowOffsetY = 2;
ctx.shadowBlur = 2;
ctx.shadowColor = '#666666';
ctx.font = '24px Arial';
ctx.fillStyle = '#333333';
ctx.fillText('带阴影的文字', 20, 40);
```
2. 


3. Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：

4. 


#### 练习 
1. 请根据从163获取的JSON数据绘制最近30个交易日的K线图，数据已处理为包含一组对象的数组：

2. 
function downloadStockImage() {
    var
        canvas = document.getElementById('stock-canvas'),
        data = canvas.toDataURL();
    window.open(data.replace('image/png', 'image/octet-stream'));
}


```
```
```
'use strict';

window.loadStockData = function (r) {
    var
        NUMS = 30,
        data = r.data;
    if (data.length > NUMS) {
        data = data.slice(data.length - NUMS);
    }
    data = data.map(function (x) {
        return {
            date: x[0],
            open: x[1],
            close: x[2],
            high: x[3],
            low: x[4],
            vol: x[5],
            change: x[6]
        };
    });
    window.drawStock(data);
}

window.drawStock = function (data) {
----
    var
        canvas = document.getElementById('stock-canvas'),
        width = canvas.width,
        height = canvas.height,
        ctx = canvas.getContext('2d');
    console.log(JSON.stringify(data[0])); // {"date":"20150602","open":4844.7,"close":4910.53,"high":4911.57,"low":4797.55,"vol":62374809900,"change":1.69}
    ctx.clearRect(0, 0, width, height);
    ctx.fillText('Test Canvas', 10, 10);
----
};

// 加载最近30个交易日的K线图数据:
var js = document.createElement('script');
js.src = 'http://img1.money.126.net/data/hs/kline/day/history/2015/0000001.json?callback=loadStockData&t=' + Date.now();
document.getElementsByTagName('head')[0].appendChild(js);
```
3. None

4. None

### Promise
1. 在JavaScript的世界中，所有代码都是单线程执行的。

2. 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：

```
function callback() {
    console.log('Done');
}
console.log('before setTimeout()');
setTimeout(callback, 1000); // 1秒钟后调用callback函数
console.log('after setTimeout()');
```
3. 观察上述代码执行，在Chrome的控制台输出可以看到：

```
before setTimeout()
after setTimeout()
(等待1秒后)
Done
```
4. 可见，异步操作会在将来的某个时间点触发一个函数调用。

5. AJAX就是典型的异步操作。以上一节的代码为例：

```
request.onreadystatechange = function () {
    if (request.readyState === 4) {
        if (request.status === 200) {
            return success(request.responseText);
        } else {
            return fail(request.status);
        }
    }
}
```
6. 把回调函数

7. 有没有更好的写法？比如写成这样：

```
var ajax = ajaxGet('http://...');
ajax.ifSuccess(success)
    .ifFail(fail);
```
8. 这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用

9. 古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。

10. Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。先测试一下你的浏览器是否支持Promise：

```
'use strict';

new Promise(function () {});
----
// 直接运行测试:
console.log('支持Promise!');
```
11. 我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：

```
function test(resolve, reject) {
    var timeOut = Math.random() * 2;
    log('set timeout to: ' + timeOut + ' seconds.');
    setTimeout(function () {
        if (timeOut < 1) {
            log('call resolve()...');
            resolve('200 OK');
        }
        else {
            log('call reject()...');
            reject('timeout in ' + timeOut + ' seconds.');
        }
    }, timeOut * 1000);
}
```
12. 这个

13. 有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：

```
var p1 = new Promise(test);
var p2 = p1.then(function (result) {
    console.log('成功：' + result);
});
var p3 = p2.catch(function (reason) {
    console.log('失败：' + reason);
});
```
14. 变量

```
// 如果成功，执行这个函数：
p1.then(function (result) {
    console.log('成功：' + result);
});
```
15. 当

```
p2.catch(function (reason) {
    console.log('失败：' + reason);
});
```
16. Promise对象可以串联起来，所以上述代码可以简化为：

```
new Promise(test).then(function (result) {
    console.log('成功：' + result);
}).catch(function (reason) {
    console.log('失败：' + reason);
});
```
17. 实际测试一下，看看Promise是如何异步执行的：

```
'use strict';

// 清除log:
var logging = document.getElementById('test-promise-log');
while (logging.children.length > 1) {
    logging.removeChild(logging.children[logging.children.length - 1]);
}

// 输出log到页面:
function log(s) {
    var p = document.createElement('p');
    p.innerHTML = s;
    logging.appendChild(p);
}

----
new Promise(function (resolve, reject) {
    log('start new Promise...');
    var timeOut = Math.random() * 2;
    log('set timeout to: ' + timeOut + ' seconds.');
    setTimeout(function () {
        if (timeOut < 1) {
            log('call resolve()...');
            resolve('200 OK');
        }
        else {
            log('call reject()...');
            reject('timeout in ' + timeOut + ' seconds.');
        }
    }, timeOut * 1000);
}).then(function (r) {
    log('Done: ' + r);
}).catch(function (reason) {
    log('Failed: ' + reason);
});
```
18. 
    

19. 可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：

20. None

21. Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。

22. 要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：

```
job1.then(job2).then(job3).catch(handleError);
```
23. 其中，

24. 下面的例子演示了如何串行执行一系列需要异步计算获得结果的任务：

```
'use strict';

var logging = document.getElementById('test-promise2-log');
while (logging.children.length > 1) {
    logging.removeChild(logging.children[logging.children.length - 1]);
}

function log(s) {
    var p = document.createElement('p');
    p.innerHTML = s;
    logging.appendChild(p);
}

----
// 0.5秒后返回input*input的计算结果:
function multiply(input) {
    return new Promise(function (resolve, reject) {
        log('calculating ' + input + ' x ' + input + '...');
        setTimeout(resolve, 500, input * input);
    });
}

// 0.5秒后返回input+input的计算结果:
function add(input) {
    return new Promise(function (resolve, reject) {
        log('calculating ' + input + ' + ' + input + '...');
        setTimeout(resolve, 500, input + input);
    });
}

var p = new Promise(function (resolve, reject) {
    log('start new Promise...');
    resolve(123);
});

p.then(multiply)
 .then(add)
 .then(multiply)
 .then(add)
 .then(function (result) {
    log('Got value: ' + result);
});
```
25. 
    

26. None

```
'use strict';

// ajax函数将返回Promise对象:
function ajax(method, url, data) {
    var request = new XMLHttpRequest();
    return new Promise(function (resolve, reject) {
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    resolve(request.responseText);
                } else {
                    reject(request.status);
                }
            }
        };
        request.open(method, url);
        request.send(data);
    });
}
----
var log = document.getElementById('test-promise-ajax-result');
var p = ajax('GET', '/api/categories');
p.then(function (text) { // 如果AJAX成功，获得响应内容
    log.innerText = text;
}).catch(function (status) { // 如果AJAX失败，获得响应代码
    log.innerText = 'ERROR: ' + status;
});
```
27. 
    Result:


28. 除了串行执行若干异步任务外，Promise还可以并行执行异步任务。

29. 试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用

```
var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
// 同时执行p1和p2，并在它们都完成后执行then:
Promise.all([p1, p2]).then(function (results) {
    console.log(results); // 获得一个Array: ['P1', 'P2']
});
```
30. 有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用

```
var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
Promise.race([p1, p2]).then(function (result) {
    console.log(result); // 'P1'
});
```
31. 由于

32. 如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。

### 操作文件
1. 在HTML表单中，可以上传文件的唯一控件就是

2. None

3. 出于安全考虑，浏览器只允许用户点击

4. 
$(function () {
    var
        fileInput = document.getElementById('test-file-upload'),
        filePath = document.getElementById('test-get-filename');
    fileInput.addEventListener('change', function () {
        filePath.innerText = fileInput.value;
    });
});


5. 
    

6. 通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：

```
var f = document.getElementById('test-file-upload');
var filename = f.value; // 'C:\fakepath\test.png'
if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) {
    alert('Can only upload image file.');
    return false;
}
```
#### File API 
1. 由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。

2. 随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。

3. HTML5的File API提供了

4. 下面的例子演示了如何读取用户选取的图片文件，并在一个

5. 
$(function() {
    var fileInput = document.getElementById('test-image-file');
    var info = document.getElementById('test-file-info');
    var preview = document.getElementById('test-image-preview');
    fileInput.addEventListener('change', function () {
        preview.style.backgroundImage = '';
        if (!fileInput.value) {
            info.innerHTML = '没有选择文件';
            return;
        }
        var file = fileInput.files[0];
        info.innerHTML = '文件: ' + file.name + '<br>' +
                         '大小: ' + file.size + '<br>' +
                         '修改: ' + file.lastModifiedDate;
        if (file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') {
            alert('不是有效的图片文件!');
            return;
        }
        var reader = new FileReader();
        reader.onload = function(e) {
            var
                data = e.target.result;
                index = data.indexOf(';base64,');
            preview.style.backgroundImage = 'url(' + data + ')';
        };
        reader.readAsDataURL(file);
    });
});


6. 
    

```
var
    fileInput = document.getElementById('test-image-file'),
    info = document.getElementById('test-file-info'),
    preview = document.getElementById('test-image-preview');
// 监听change事件:
fileInput.addEventListener('change', function () {
    // 清除背景图片:
    preview.style.backgroundImage = '';
    // 检查文件是否选择:
    if (!fileInput.value) {
        info.innerHTML = '没有选择文件';
        return;
    }
    // 获取File引用:
    var file = fileInput.files[0];
    // 获取File信息:
    info.innerHTML = '文件: ' + file.name + '<br>' +
                     '大小: ' + file.size + '<br>' +
                     '修改: ' + file.lastModifiedDate;
    if (file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') {
        alert('不是有效的图片文件!');
        return;
    }
    // 读取文件:
    var reader = new FileReader();
    reader.onload = function(e) {
        var
            data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            
        preview.style.backgroundImage = 'url(' + data + ')';
    };
    // 以DataURL的形式读取文件:
    reader.readAsDataURL(file);
});
```
7. 上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于

#### 回调 
1. 上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。

2. 你可能会问，单线程模式执行的JavaScript，如何处理多任务？

3. 在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：

```
reader.readAsDataURL(file);
```
4. 就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：

```
reader.onload = function(e) {
    // 当文件读取完成后，自动调用此函数:
};
```
5. 当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。

### 浏览器对象
1. JavaScript可以获取浏览器提供的很多对象，并进行操作。

#### window 
1. None

2. None

3. 兼容性：IE<=8不支持。

```
'use strict';
----
// 可以调整浏览器窗口大小试试:
console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight);
```
4. 对应的，还有一个

#### navigator 
1. None

2. 


```
'use strict';
----
console.log('appName = ' + navigator.appName);
console.log('appVersion = ' + navigator.appVersion);
console.log('language = ' + navigator.language);
console.log('platform = ' + navigator.platform);
console.log('userAgent = ' + navigator.userAgent);
```
3. None

```
var width;
if (getIEVersion(navigator.userAgent) < 9) {
    width = document.body.clientWidth;
} else {
    width = window.innerWidth;
}
```
4. 但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回

```
var width = window.innerWidth || document.body.clientWidth;
```
#### screen 
1. None

2. 


```
'use strict';
----
console.log('Screen size = ' + screen.width + ' x ' + screen.height);
```
#### location 
1. None

```
http://www.example.com:8080/path/index.html?a=1&b=2#TOP
```
2. 可以用

```
location.protocol; // 'http'
location.host; // 'www.example.com'
location.port; // '8080'
location.pathname; // '/path/index.html'
location.search; // '?a=1&b=2'
location.hash; // 'TOP'
```
3. 要加载一个新页面，可以调用

```
'use strict';
----
if (confirm('重新加载当前页' + location.href + '?')) {
    location.reload();
} else {
    location.assign('/'); // 设置一个新的URL地址
}
```
#### document 
1. None

2. None

```
'use strict';
----
document.title = '努力学习JavaScript!';
```
3. 请观察浏览器窗口标题的变化。

4. 要查找DOM树的某个节点，需要从

5. 我们先准备HTML数据：

```
<dl id="drink-menu" style="border:solid 1px #ccc;padding:6px;">
    <dt>摩卡</dt>
    <dd>热摩卡咖啡</dd>
    <dt>酸奶</dt>
    <dd>北京老酸奶</dd>
    <dt>果汁</dt>
    <dd>鲜榨苹果汁</dd>
</dl>
```
6. 用

```
'use strict';
----
var menu = document.getElementById('drink-menu');
var drinks = document.getElementsByTagName('dt');
var i, s;

s = '提供的饮料有:';
for (i=0; i<drinks.length; i++) {
    s = s + drinks[i].innerHTML + ',';
}
console.log(s);
```
7. 
    

8. None

9. Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如

10. Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。

11. JavaScript可以通过

```
document.cookie; // 'v=123; remember=true; prefer=zh'
```
12. 由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：

```
<!-- 当前页面在wwwexample.com -->
<html>
    <head>
        <script src="http://www.foo.com/jquery.js"></script>
    </head>
    ...
</html>
```
13. 如果引入的第三方的JavaScript中存在恶意代码，则

14. 为了解决这个问题，服务器在设置Cookie时可以使用

15. 为了确保安全，服务器端在设置Cookie时，应该始终坚持使用

#### history 
1. None

2. 这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用

3. 新手开始设计Web页面时喜欢在登录页登录成功时调用

4. 任何情况，你都不应该使用

### 操作表单
1. 用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。

2. 不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。

3. HTML表单的输入控件主要有以下几种：

4. 


#### 获取值 
1. 如果我们获得了一个

```
// <input type="text" id="email">
var input = document.getElementById('email');
input.value; // '用户输入的值'
```
2. 这种方式可以应用于

```
// <label><input type="radio" name="weekday" id="monday" value="1"> Monday</label>
// <label><input type="radio" name="weekday" id="tuesday" value="2"> Tuesday</label>
var mon = document.getElementById('monday');
var tue = document.getElementById('tuesday');
mon.value; // '1'
tue.value; // '2'
mon.checked; // true或者false
tue.checked; // true或者false
```
#### 设置值 
1. 设置值和获取值类似，对于

```
// <input type="text" id="email">
var input = document.getElementById('email');
input.value = 'test@example.com'; // 文本框的内容已更新
```
2. 对于单选框和复选框，设置

#### HTML5控件 
1. HTML5新增了大量标准控件，常用的包括

```
<input type="date" value="2015-07-01">
```
2. None

```
<input type="datetime-local" value="2015-07-01T02:03:04">
```
3. None

```
<input type="color" value="#ff0000">
```
4. None

5. 不支持HTML5的浏览器无法识别新的控件，会把它们当做

#### 提交表单 
1. 最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。

2. 方式一是通过

```
<!-- HTML -->
<form id="test-form">
    <input type="text" name="test">
    <button type="button" onclick="doSubmitForm()">Submit</button>
</form>

<script>
function doSubmitForm() {
    var form = document.getElementById('test-form');
    // 可以在此修改form的input...
    // 提交form:
    form.submit();
}
</script>
```
3. 这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击

```
<!-- HTML -->
<form id="test-form" onsubmit="return checkForm()">
    <input type="text" name="test">
    <button type="submit">Submit</button>
</form>

<script>
function checkForm() {
    var form = document.getElementById('test-form');
    // 可以在此修改form的input...
    // 继续下一步:
    return true;
}
</script>
```
4. 注意要

5. 在检查和修改

6. 例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改

```
<!-- HTML -->
<form id="login-form" method="post" onsubmit="return checkForm()">
    <input type="text" id="username" name="username">
    <input type="password" id="password" name="password">
    <button type="submit">Submit</button>
</form>

<script>
function checkForm() {
    var pwd = document.getElementById('password');
    // 把用户输入的明文变为MD5:
    pwd.value = toMD5(pwd.value);
    // 继续下一步:
    return true;
}
</script>
```
7. 这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个

8. 要想不改变用户的输入，可以利用

```
<!-- HTML -->
<form id="login-form" method="post" onsubmit="return checkForm()">
    <input type="text" id="username" name="username">
    <input type="password" id="input-password">
    <input type="hidden" id="md5-password" name="password">
    <button type="submit">Submit</button>
</form>

<script>
function checkForm() {
    var input_pwd = document.getElementById('input-password');
    var md5_pwd = document.getElementById('md5-password');
    // 把用户输入的明文变为MD5:
    md5_pwd.value = toMD5(input_pwd.value);
    // 继续下一步:
    return true;
}
</script>
```
9. 注意到

#### 练习 
1. 利用JavaScript检查用户注册信息是否正确，在以下情况不满足时报错并阻止提交表单：

2. 


```
<!-- HTML结构 -->
<form id="test-register" action="#" target="_blank" onsubmit="return checkRegisterForm()">
    <p id="test-error" style="color:red"></p>
    <p>
        用户名: <input type="text" id="username" name="username">
    </p>
    <p>
        口令: <input type="password" id="password" name="password">
    </p>
    <p>
        重复口令: <input type="password" id="password-2">
    </p>
    <p>
        <button type="submit">提交</button> <button type="reset">重置</button>
    </p>
</form>
```
3. 
    

4. 
window.testFormHandler = function () {
    return false;
}

function checkForm() {
    var r = window.testFormHandler();
    if (r === false) {
        console.log('checkRegisterForm() return false!');
    } else {
        alert('Form可以正常提交！');
    }
    return r;
}


```
'use strict';
var checkRegisterForm = function () {
----
    // TODO:
    return false;
}
----
// 测试:
;(function () {
    window.testFormHandler = checkRegisterForm;
    var form = document.getElementById('test-register');
    if (form.dispatchEvent) {
        var event = new Event('submit', {
    		bubbles: true,
    		cancelable: true
  		});
        form.dispatchEvent(event);
    } else {
        form.fireEvent('onsubmit');
    }
})();
```
### 操作DOM
1. 由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。

2. 始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：

3. 


4. 在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是

5. 由于ID在HTML文档中是唯一的，所以

6. 例如：

```
// 返回ID为'test'的节点：
var test = document.getElementById('test');

// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：
var trs = document.getElementById('test-table').getElementsByTagName('tr');

// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：
var reds = document.getElementById('test-div').getElementsByClassName('red');

// 获取节点test下的所有直属子节点:
var cs = test.children;

// 获取节点test下第一个、最后一个子节点：
var first = test.firstElementChild;
var last = test.lastElementChild;
```
7. 第二种方法是使用

```
// 通过querySelector获取ID为q1的节点：
var q1 = document.querySelector('#q1');

// 通过querySelectorAll获取q1节点内的符合条件的所有节点：
var ps = q1.querySelectorAll('div.highlighted > p');
```
8. 注意：低版本的IE<8不支持

9. 严格地讲，我们这里的DOM节点是指

#### 练习 
1. 如下的HTML结构：

2. 
  

```
<!-- HTML结构 -->
<div id="test-div">
<div class="c-red">
    <p id="test-p">JavaScript</p>
    <p>Java</p>
  </div>
  <div class="c-red c-green">
    <p>Python</p>
    <p>Ruby</p>
    <p>Swift</p>
  </div>
  <div class="c-green">
    <p>Scheme</p>
    <p>Haskell</p>
  </div>
</div>
```
3. 请选择出指定条件的节点：

```
'use strict';
----
// 选择<p>JavaScript</p>:
var js = ???;

// 选择<p>Python</p>,<p>Ruby</p>,<p>Swift</p>:
var arr = ???;

// 选择<p>Haskell</p>:
var haskell = ???;
----
// 测试:
if (!js || js.innerText !== 'JavaScript') {
    alert('选择JavaScript失败!');
} else if (!arr || arr.length !== 3 || !arr[0] || !arr[1] || !arr[2] || arr[0].innerText !== 'Python' || arr[1].innerText !== 'Ruby' || arr[2].innerText !== 'Swift') {
    console.log('选择Python,Ruby,Swift失败!');
} else if (!haskell || haskell.innerText !== 'Haskell') {
    console.log('选择Haskell失败!');
} else {
    console.log('测试通过!');
}
```
### AJAX
1. AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。

2. 如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。

3. 这就是Web的运作原理：一次HTTP请求对应一个页面。

4. 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。

5. 最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。

6. 用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。

7. 在现代浏览器上写AJAX主要依靠

```
'use strict';
----
function success(text) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = 'Error code: ' + code;
}

var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open('GET', '/api/categories');
request.send();

alert('请求已发送，请等待响应...');
```
8. 
响应结果：


9. 对于低版本的IE，需要换一个

```
'use strict';
----
function success(text) {
    var textarea = document.getElementById('test-ie-response-text');
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById('test-ie-response-text');
    textarea.value = 'Error code: ' + code;
}

var request = new ActiveXObject('Microsoft.XMLHTTP'); // 新建Microsoft.XMLHTTP对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open('GET', '/api/categories');
request.send();

alert('请求已发送，请等待响应...');
```
10. 
IE响应结果：


11. 如果你想把标准写法和IE写法混在一起，可以这么写：

```
var request;
if (window.XMLHttpRequest) {
    request = new XMLHttpRequest();
} else {
    request = new ActiveXObject('Microsoft.XMLHTTP');
}
```
12. 通过检测

13. 当创建了

14. None

15. None

16. 最后调用

#### 安全限制 
1. 上面代码的URL使用的是相对路径。如果你把它改为

2. 这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。

3. 完全一致的意思是，域名要相同（

4. 那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：

5. 一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。

6. 二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：

```
'/proxy?url=http://www.sina.com.cn'
```
7. 代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。

8. 第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：

```
<html>
<head>
    <script src="http://example.com/abc.js"></script>
    ...
</head>
<body>
...
</body>
</html>
```
9. JSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下：

```
foo('data');
```
10. 这样一来，我们如果在页面中先准备好

11. 以163的股票查询URL为例，对于URL：

```
refreshPrice({"0000001":{"code": "0000001", ... });
```
12. 因此我们需要首先在页面中准备好回调函数：

13. 
function refreshPrice(data) {
    var p = document.getElementById('test-jsonp');
    p.innerHTML = '当前价格：' +
        data['0000001'].name +': ' + 
        data['0000001'].price + '；' +
        data['1399001'].name + ': ' +
        data['1399001'].price;
}
function getPrice() {
    var
        js = document.createElement('script'),
        head = document.getElementsByTagName('head')[0];
    js.src = 'http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice';
    head.appendChild(js);
}


```
function refreshPrice(data) {
    var p = document.getElementById('test-jsonp');
    p.innerHTML = '当前价格：' +
        data['0000001'].name +': ' + 
        data['0000001'].price + '；' +
        data['1399001'].name + ': ' +
        data['1399001'].price;
}
```
14. 
    

15. 最后用

```
function getPrice() {
    var
        js = document.createElement('script'),
        head = document.getElementsByTagName('head')[0];
    js.src = 'http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice';
    head.appendChild(js);
}
```
16. 就完成了跨域加载数据。

#### CORS 
1. 如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。

2. CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。

3. 了解CORS前，我们先搞明白概念：

4. Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查

5. 用一个图来表示就是：

6. None

7. 假设本域是

8. 可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的

9. 上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型
仅限

10. 无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：

```
/* CSS */
@font-face {
  font-family: 'FontAwesome';
  src: url('http://cdn.com/fonts/fontawesome.ttf') format('truetype');
}
```
11. 如果该CDN服务商未正确设置

12. 对于PUT、DELETE以及其他类型如

```
OPTIONS /path/to/resource HTTP/1.1
Host: bar.com
Origin: http://my.com
Access-Control-Request-Method: POST
```
13. 服务器必须响应并明确指出允许的Method：

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://my.com
Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS
Access-Control-Max-Age: 86400
```
14. 浏览器确认服务器响应的

15. 由于以

16. 需要深入了解CORS的童鞋请移步

## 函数
### 闭包
#### 函数作为返回值 
1. 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。

2. 我们来实现一个对

```
function sum(arr) {
    return arr.reduce(function (x, y) {
        return x + y;
    });
}

sum([1, 2, 3, 4, 5]); // 15
```
3. 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！

```
function lazy_sum(arr) {
    var sum = function () {
        return arr.reduce(function (x, y) {
            return x + y;
        });
    }
    return sum;
}
```
4. 当我们调用

```
var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()
```
5. 调用函数

```
f(); // 15
```
6. 在这个例子中，我们在函数

7. 请再注意一点，当我们调用

```
var f1 = lazy_sum([1, 2, 3, 4, 5]);
var f2 = lazy_sum([1, 2, 3, 4, 5]);
f1 === f2; // false
```
8. None

#### 闭包 
1. 注意到返回的函数在其定义内部引用了局部变量

2. 另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了

```
function count() {
    var arr = [];
    for (var i=1; i<=3; i++) {
        arr.push(function () {
            return i * i;
        });
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];
```
3. 在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个

4. 你可能认为调用

```
f1(); // 16
f2(); // 16
f3(); // 16
```
5. 全部都是

6. 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。

7. 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：

```
function count() {
    var arr = [];
    for (var i=1; i<=3; i++) {
        arr.push((function (n) {
            return function () {
                return n * n;
            }
        })(i));
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];

f1(); // 1
f2(); // 4
f3(); // 9
```
8. 注意这里用了一个“创建一个匿名函数并立刻执行”的语法：

```
(function (x) {
    return x * x;
})(3); // 9
```
9. 理论上讲，创建一个匿名函数并立刻执行可以这么写：

```
function (x) { return x * x } (3);
```
10. 但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：

```
(function (x) { return x * x }) (3);
```
11. 通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：

```
(function (x) {
    return x * x;
})(3);
```
12. 说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？

13. 当然不是！闭包有非常强大的功能。举个栗子：

14. 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用

15. 在没有

```
'use strict';

function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}
```
16. 它用起来像这样：

```
var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```
17. 在返回的对象中，实现了一个闭包，该闭包携带了局部变量

18. 闭包还可以把多参数的函数变成单参数的函数。例如，要计算x

```
'use strict';

function make_pow(n) {
    return function (x) {
        return Math.pow(x, n);
    }
}
----
// 创建两个新函数:
var pow2 = make_pow(2);
var pow3 = make_pow(3);

console.log(pow2(5)); // 25
console.log(pow3(7)); // 343
```
#### 脑洞大开 
1. 很久很久以前，有个叫阿隆佐·邱奇的帅哥，发现只需要用函数，就可以用计算机实现运算，而不需要

2. JavaScript支持函数，所以可以用JavaScript用函数来写这些计算。来试试：

```
'use strict';

// 定义数字0:
var zero = function (f) {
    return function (x) {
        return x;
    }
};

// 定义数字1:
var one = function (f) {
    return function (x) {
        return f(x);
    }
};

// 定义加法:
function add(n, m) {
    return function (f) {
        return function (x) {
            return m(f)(n(f)(x));
        }
    }
}
----
// 计算数字2 = 1 + 1:
var two = add(one, one);

// 计算数字3 = 1 + 2:
var three = add(one, two);

// 计算数字5 = 2 + 3:
var five = add(two, three);

// 你说它是3就是3，你说它是5就是5，你怎么证明？

// 呵呵，看这里:

// 给3传一个函数,会打印3次:
(three(function () {
    console.log('print 3 times');
}))();

// 给5传一个函数,会打印5次:
(five(function () {
    console.log('print 5 times');
}))();

// 继续接着玩一会...
```
### 变量作用域与解构赋值
1. 在JavaScript中，用

2. 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：

```
'use strict';

function foo() {
    var x = 1;
    x = x + 1;
}

x = x + 2; // ReferenceError! 无法在函数体外引用变量x
```
3. 如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：

```
'use strict';

function foo() {
    var x = 1;
    x = x + 1;
}

function bar() {
    var x = 'A';
    x = x + 'B';
}
```
4. 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：

```
'use strict';

function foo() {
    var x = 1;
    function bar() {
        var y = x + 1; // bar可以访问foo的变量x!
    }
    var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
}
```
5. 如果内部函数和外部函数的变量名重名怎么办？来测试一下：

```
'use strict';
----
function foo() {
    var x = 1;
    function bar() {
        var x = 'A';
        console.log('x in bar() = ' + x); // 'A'
    }
    console.log('x in foo() = ' + x); // 1
    bar();
}

foo();
```
6. 这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。

#### 变量提升 
1. JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：

```
'use strict';

function foo() {
    var x = 'Hello, ' + y;
    console.log(x);
    var y = 'Bob';
}

foo();
```
2. 虽然是strict模式，但语句

3. 对于上述

```
function foo() {
    var y; // 提升变量y的申明，此时y为undefined
    var x = 'Hello, ' + y;
    console.log(x);
    y = 'Bob';
}
```
4. 由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个

```
function foo() {
    var
        x = 1, // x初始化为1
        y = x + 1, // y初始化为2
        z, i; // z和i为undefined
    // 其他语句:
    for (i=0; i<100; i++) {
        ...
    }
}
```
#### 全局作用域 
1. 不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象

```
'use strict';

var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript'
```
2. 因此，直接访问全局变量

3. 你可能猜到了，由于函数定义有两种方式，以变量方式

```
'use strict';

function foo() {
    alert('foo');
}

foo(); // 直接调用foo()
window.foo(); // 通过window.foo()调用
```
4. 进一步大胆地猜测，我们每次直接调用的

```
'use strict';

window.alert('调用window.alert()');
// 把alert保存到另一个变量:
var old_alert = window.alert;
// 给alert赋一个新函数:
window.alert = function () {}
----
alert('无法用alert()显示了!');
----
// 恢复alert:
window.alert = old_alert;
alert('又可以用alert()了!');
```
5. 这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报

#### 名字空间 
1. 全局变量会绑定到

2. 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：

```
// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = 'myapp';
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return 'foo';
};
```
3. 把自己的代码全部放入唯一的名字空间

4. 许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。

#### 局部作用域 
1. 由于JavaScript的变量作用域实际上是函数内部，我们在

```
'use strict';

function foo() {
    for (var i=0; i<100; i++) {
        //
    }
    i += 100; // 仍然可以引用变量i
}
```
2. 为了解决块级作用域，ES6引入了新的关键字

```
'use strict';

function foo() {
    var sum = 0;
    for (let i=0; i<100; i++) {
        sum += i;
    }
    // SyntaxError:
    i += 1;
}
```
#### 常量 
1. 由于

```
var PI = 3.14;
```
2. ES6标准引入了新的关键字

```
'use strict';

const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```
#### 解构赋值 
1. 从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。

2. 什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量：

```
var array = ['hello', 'JavaScript', 'ES6'];
var x = array[0];
var y = array[1];
var z = array[2];
```
3. 现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值：

```
'use strict';

// 如果浏览器支持解构赋值就不会报错:
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
----
// x, y, z分别被赋值为数组对应元素:
console.log('x = ' + x + ', y = ' + y + ', z = ' + z);
```
4. 注意，对数组元素进行解构赋值时，多个变量要用

5. 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致：

```
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];
x; // 'hello'
y; // 'JavaScript'
z; // 'ES6'
```
6. 解构赋值还可以忽略某些元素：

```
let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```
7. 如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：

```
'use strict';

var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school'
};
var {name, age, passport} = person;
----
// name, age, passport分别被赋值为对应属性:
console.log('name = ' + name + ', age = ' + age + ', passport = ' + passport);
```
8. 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的：

```
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school',
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};
var {name, address: {city, zip}} = person;
name; // '小明'
city; // 'Beijing'
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined
```
9. 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为

```
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school'
};

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined
```
10. 解构赋值还可以使用默认值，这样就避免了不存在的属性返回

```
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678'
};

// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
name; // '小明'
single; // true
```
11. 有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：

```
// 声明变量:
var x, y;
// 解构赋值:
{x, y} = { name: '小明', x: 100, y: 200};
// 语法错误: Uncaught SyntaxError: Unexpected token =
```
12. 这是因为JavaScript引擎把

```
({x, y} = { name: '小明', x: 100, y: 200});
```
#### 使用场景 
1. 解构赋值在很多时候可以大大简化代码。例如，交换两个变量

```
var x=1, y=2;
[x, y] = [y, x]
```
2. 快速获取当前页面的域名和路径：

```
var {hostname:domain, pathname:path} = location;
```
3. 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个

```
function buildDate({year, month, day, hour=0, minute=0, second=0}) {
    return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);
}
```
4. 它的方便之处在于传入的对象只需要

```
buildDate({ year: 2017, month: 1, day: 1 });
// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)
```
5. 也可以传入

```
buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 });
// Sun Jan 01 2017 20:15:00 GMT+0800 (CST)
```
6. 使用解构赋值可以减少代码量，但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行。目前支持解构赋值的浏览器包括Chrome，Firefox，Edge等。

### 函数定义和调用
#### 定义函数 
1. 在JavaScript中，定义函数的方式如下：

```
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```
2. 上述

3. 


4. 请注意，函数体内部的语句在执行时，一旦执行到

5. 如果没有

6. 由于JavaScript的函数也是一个对象，上述定义的

7. 因此，第二种定义函数的方式如下：

```
var abs = function (x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
};
```
8. 在这种方式下，

9. 上述两种定义

#### 调用函数 
1. 调用函数时，按顺序传入参数即可：

```
abs(10); // 返回10
abs(-9); // 返回9
```
2. 由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：

```
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
```
3. 传入的参数比定义的少也没有问题：

```
abs(); // 返回NaN
```
4. 此时

5. 要避免收到

```
function abs(x) {
    if (typeof x !== 'number') {
        throw 'Not a number';
    }
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```
#### arguments 
1. JavaScript还有一个免费赠送的关键字

```
'use strict'
----
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
```
2. 利用

```
function abs() {
    if (arguments.length === 0) {
        return 0;
    }
    var x = arguments[0];
    return x >= 0 ? x : -x;
}

abs(); // 0
abs(10); // 10
abs(-9); // 9
```
3. 实际上

```
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```
4. 要把中间的参数

#### rest参数 
1. 由于JavaScript函数允许接收任意个参数，于是我们就不得不用

```
function foo(a, b) {
    var i, rest = [];
    if (arguments.length > 2) {
        for (i = 2; i<arguments.length; i++) {
            rest.push(arguments[i]);
        }
    }
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}
```
2. 为了获取除了已定义参数

3. ES6标准引入了rest参数，上面的函数可以改写为：

```
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```
4. rest参数只能写在最后，前面用

5. 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是

6. 因为rest参数是ES6新标准，所以你需要测试一下浏览器是否支持。请用rest参数编写一个

```
'use strict';
----
function sum(...rest) {
   ???
}
----
// 测试:
var i, args = [];
for (i=1; i<=100; i++) {
    args.push(i);
}
if (sum() !== 0) {
    console.log('测试失败: sum() = ' + sum());
} else if (sum(1) !== 1) {
    console.log('测试失败: sum(1) = ' + sum(1));
} else if (sum(2, 3) !== 5) {
    console.log('测试失败: sum(2, 3) = ' + sum(2, 3));
} else if (sum.apply(null, args) !== 5050) {
    console.log('测试失败: sum(1, 2, 3, ..., 100) = ' + sum.apply(null, args));
} else {
    console.log('测试通过!');
}
```
#### 小心你的return语句 
1. 前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：

```
function foo() {
    return { name: 'foo' };
}

foo(); // { name: 'foo' }
```
2. 如果把return语句拆成两行：

```
function foo() {
    return
        { name: 'foo' };
}

foo(); // undefined
```
3. None

```
function foo() {
    return; // 自动添加了分号，相当于return undefined;
        { name: 'foo' }; // 这行语句已经没法执行到了
}
```
4. 所以正确的多行写法是：

```
function foo() {
    return { // 这里不会自动加分号，因为{表示语句尚未结束
        name: 'foo'
    };
}
```
#### 练习 
1. 定义一个计算圆面积的函数

2. 


```
'use strict';

function area_of_circle(r, pi) {
----
    return 0;
----
}
// 测试:
if (area_of_circle(2) === 12.56 && area_of_circle(2, 3.1416) === 12.5664) {
    console.log('测试通过');
} else {
    console.log('测试失败');
}
```
3. 小明是一个JavaScript新手，他写了一个

```
'use strict';

function max(a, b) {
----
    if (a > b) {
        return
                a;
    } else {
        return
                b;
    }
----
}
console.log(max(15, 20));
```
4. 但是小明抱怨他的浏览器出问题了，无论传入什么数，

### 高阶函数
1. 高阶函数英文叫Higher-order function。那么什么是高阶函数？

2. JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

3. 一个最简单的高阶函数：

```
function add(x, y, f) {
    return f(x) + f(y);
}
```
4. 当我们调用

```
x = -5;
y = 6;
f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```
5. 用代码验证一下：

```
'use strict';

function add(x, y, f) {
    return f(x) + f(y);
}
----
var x = add(-5, 6, Math.abs); // 11
console.log(x);
```
6. 编写高阶函数，就是让函数的参数能够接收别的函数。

### 箭头函数
1. ES6标准新增了一种新的函数：Arrow Function（箭头函数）。

2. 为什么叫Arrow Function？因为它的定义用的就是一个箭头：

```
x => x * x
```
3. 上面的箭头函数相当于：

```
function (x) {
    return x * x;
}
```
4. 在继续学习箭头函数之前，请测试你的浏览器是否支持ES6的Arrow Function：

```
'use strict';
----
var fn = x => x * x;
----
console.log('你的浏览器支持ES6的Arrow Function!');
```
5. 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连

```
x => {
    if (x > 0) {
        return x * x;
    }
    else {
        return - x * x;
    }
}
```
6. 如果参数不是一个，就需要用括号

```
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```
7. 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：

```
// SyntaxError:
x => { foo: x }
```
8. 因为和函数体的

```
// ok:
x => ({ foo: x })
```
#### this 
1. 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的

2. 回顾前面的例子，由于JavaScript函数对

```
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
        return fn();
    }
};
```
3. 现在，箭头函数完全修复了

```
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25
```
4. 如果使用箭头函数，以前的那种hack写法：

```
var that = this;
```
5. 就不再需要了。

6. 由于

```
var obj = {
    birth: 1990,
    getAge: function (year) {
        var b = this.birth; // 1990
        var fn = (y) => y - this.birth; // this.birth仍是1990
        return fn.call({birth:2000}, year);
    }
};
obj.getAge(2015); // 25
```
#### 练习 
1. 请使用箭头函数简化排序时传入的函数：

```
'use strict'
var arr = [10, 20, 1, 2];
----
arr.sort((x, y) => {
    ???
});
console.log(arr); // [1, 2, 10, 20]
```
### 方法
1. 在一个对象中绑定函数，称为这个对象的方法。

2. 在JavaScript中，对象的定义是这样的：

```
var xiaoming = {
    name: '小明',
    birth: 1990
};
```
3. 但是，如果我们给

```
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
```
4. 绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个

5. 在一个方法内部，

6. 让我们拆开写：

```
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```
7. 单独调用函数

8. JavaScript的函数内部如果调用了

9. 答案是，视情况而定！

10. 如果以对象的方法形式调用，比如

11. 如果单独调用函数，比如

12. 坑爹啊！

13. 更坑爹的是，如果这么写：

```
var fn = xiaoming.age; // 先拿到xiaoming的age函数
fn(); // NaN
```
14. 也是不行的！要保证

15. 由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的

```
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined
```
16. 这个决定只是让错误及时暴露出来，并没有解决

17. 有些时候，喜欢重构的你把方法重构了一下：

```
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - this.birth;
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined
```
18. 结果又报错了！原因是

19. 修复的办法也不是没有，我们用一个

```
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // 25
```
20. 用

#### apply 
1. 虽然在一个独立的函数调用中，根据是否是strict模式，

2. 要指定函数的

3. 用

```
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```
4. 另一个与

5. 


6. 比如调用

```
Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
```
7. 对普通函数调用，我们通常把

#### 装饰器 
1. 利用

2. JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。

3. 现在假定我们想统计一下代码一共调用了多少次

```
'use strict';

var count = 0;
var oldParseInt = parseInt; // 保存原函数

window.parseInt = function () {
    count += 1;
    return oldParseInt.apply(null, arguments); // 调用原函数
};
----
// 测试:
parseInt('10');
parseInt('20');
parseInt('30');
console.log('count = ' + count); // 3
```
### generator
1. generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。

2. ES6定义generator标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。如果你对Python还不熟，赶快恶补

3. 我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果：

```
function foo(x) {
    return x + x;
}

var r = foo(1); // 调用foo函数
```
4. 函数在执行过程中，如果没有遇到

5. generator跟函数很像，定义如下：

```
function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
```
6. generator和函数不同的是，generator由

7. 大多数同学立刻就晕了，generator就是能够返回多次的“函数”？返回多次有啥用？

8. 还是举个栗子吧。

9. 我们以一个著名的斐波那契数列为例，它由

```
0 1 1 2 3 5 8 13 21 34 ...
```
10. 要编写一个产生斐波那契数列的函数，可以这么写：

```
function fib(max) {
    var
        t,
        a = 0,
        b = 1,
        arr = [0, 1];
    while (arr.length < max) {
        [a, b] = [b, a + b];
        arr.push(b);
    }
    return arr;
}

// 测试:
fib(5); // [0, 1, 1, 2, 3]
fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```
11. 函数只能返回一次，所以必须返回一个

```
function* fib(max) {
    var
        t,
        a = 0,
        b = 1,
        n = 0;
    while (n < max) {
        yield a;
        [a, b] = [b, a + b];
        n ++;
    }
    return;
}
```
12. 直接调用试试：

```
fib(5); // fib {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}
```
13. 直接调用一个generator和调用函数不一样，

14. 调用generator对象有两个方法，一是不断地调用generator对象的

```
var f = fib(5);
f.next(); // {value: 0, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 1, done: false}
f.next(); // {value: 2, done: false}
f.next(); // {value: 3, done: false}
f.next(); // {value: undefined, done: true}
```
15. None

16. 当执行到

17. 第二个方法是直接用

```
'use strict'

function* fib(max) {
    var
        t,
        a = 0,
        b = 1,
        n = 0;
    while (n < max) {
        yield a;
        [a, b] = [b, a + b];
        n ++;
    }
    return;
}
----
for (var x of fib(10)) {
    console.log(x); // 依次输出0, 1, 1, 2, 3, ...
}
```
18. generator和普通函数相比，有什么用？

19. 因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写：

```
var fib = {
    a: 0,
    b: 1,
    n: 0,
    max: 5,
    next: function () {
        var
            r = this.a,
            t = this.a + this.b;
        this.a = this.b;
        this.b = t;
        if (this.n < this.max) {
            this.n ++;
            return r;
        } else {
            return undefined;
        }
    }
};
```
20. 用对象的属性来保存状态，相当繁琐。

21. generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。

22. 没有generator之前的黑暗时代，用AJAX时需要这么写代码：

```
ajax('http://url-1', data1, function (err, result) {
    if (err) {
        return handle(err);
    }
    ajax('http://url-2', data2, function (err, result) {
        if (err) {
            return handle(err);
        }
        ajax('http://url-3', data3, function (err, result) {
            if (err) {
                return handle(err);
            }
            return success(result);
        });
    });
});
```
23. 回调越多，代码越难看。

24. 有了generator的美好时代，用AJAX时可以这么写：

```
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
}
```
25. 看上去是同步的代码，实际执行是异步的。

#### 练习 
1. 要生成一个自增的ID，可以编写一个

```
var current_id = 0;

function next_id() {
    current_id ++;
    return current_id;
}
```
2. 由于函数无法保存状态，故需要一个全局变量

3. 不用闭包，试用generator改写：

```
'use strict';
function* next_id() {
----
    ???
----
}

// 测试:
var
    x,
    pass = true,
    g = next_id();
for (x = 1; x < 100; x ++) {
    if (g.next().value !== x) {
        pass = false;
        console.log('测试失败!');
        break;
    }
}
if (pass) {
    console.log('测试通过!');
}
```
## JavaScript简介
## 错误处理
### 异步错误处理
1. 编写JavaScript代码时，我们要时刻牢记，JavaScript引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。

2. 例如，

```
function printTime() {
    console.log('It is time!');
}

setTimeout(printTime, 1000);
console.log('done');
```
3. 上面的代码会先打印

4. 如果

```
'use strict';
----
function printTime() {
    throw new Error();
}

try {
    setTimeout(printTime, 1000);
    console.log('done');
} catch (e) {
    console.log('error');
}
----
// 直接运行，看是否会alert
```
5. 原因就在于调用

6. 所以，涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。

7. 类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。

8. 例如，针对以下的表单：

```
<form>
    <input id="x"> + <input id="y">
    <button id="calc" type="button">计算</button>
</form>
```
9. 
    

10. 我们用下面的代码给button绑定click事件：

```
'use strict';

var $btn = $('#calc');

// 取消已绑定的事件:
$btn.off('click');
----
try {
    $btn.click(function () {
        var
            x = parseFloat($('#x').val()),
            y = parseFloat($('#y').val()),
            r;
        if (isNaN(x) || isNaN(y)) {
            throw new Error('输入有误');
        }
        r = x + y;
        alert('计算结果：' + r);
    });
} catch (e) {
    alert('输入有误！');
}
```
11. 但是，用户输入错误时，处理函数并未捕获到错误。请修复错误处理代码。

### 错误传播
1. 如果代码发生了错误，又没有被try ... catch捕获，那么，程序执行流程会跳转到哪呢？

```
function getLength(s) {
    return s.length;
}

function printLength() {
    console.log(getLength('abc')); // 3
    console.log(getLength(null)); // Error!
}

printLength();
```
2. 如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。

3. 所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽：

```
'use strict';
----
function main(s) {
    console.log('BEGIN main()');
    try {
        foo(s);
    } catch (e) {
        console.log('出错了：' + e);
    }
    console.log('END main()');
}

function foo(s) {
    console.log('BEGIN foo()');
    bar(s);
    console.log('END foo()');
}

function bar(s) {
    console.log('BEGIN bar()');
    console.log('length = ' + s.length);
    console.log('END bar()');
}

main(null);
----
// 直接运行，观察控制台输出
```
4. 当

5. 至于在哪些地方捕获错误比较合适，需要视情况而定。

## React
### 第一个React应用
1. New wiki page content

```
<!-- learn react -->
----
<html>
<head>
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
<script type="text/babel">

ReactDOM.render(
    <h1>Hello, world!</h1>,
    document.getElementById('root')
);

</script>
</body>
</html>
```
### 元素渲染
1. New wiki page content

```
<!-- learn react -->
----
<html>
<head>
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
<script type="text/babel">

const clock = (
    // 一个React DOM元素只能有一个根元素，因此
    // <h1>和<p>必须用一个根元素包起来：
    <div>
        <h1>Clock</h1>
        <p>It is { new Date().toLocaleString() }</p>
    </div>
);

ReactDOM.render(
    clock,
    document.getElementById('root')
);

</script>
</body>
</html>
```
### 组件
1. New wiki page content

```
<!-- learn react -->
----
<html>
<head>
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
<script type="text/babel">

function Welcome(props) {
    return <h1>Hello, {props.name}</h1>
}

function App() {
    return (
        <div>
            <Welcome name="Bob"/>
            <Welcome name="Alice"/>
            <Welcome name="Tom"/>
        </div>
    )
}

ReactDOM.render(
    <App/>,
    document.getElementById('root')
);

</script>
</body>
</html>
```
### 组件和状态
1. New wiki page content

```
<!-- learn react -->
----
<html>
<head>
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
<script type="text/babel">

class Welcome extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            date: new Date()
        }
    }

    render() {
        const
            hour = this.state.date.getHours(),
            hello = hour < 12 ? "Good morning" : (hour > 18 ? "Good afternoon" : "Good evening"),
            time = this.state.date.toLocaleTimeString();
        return (
            <div>
                <h1>{hello}, {this.props.name}</h1>
                <h2>It is {time}</h2>
            </div>
        );
    }
}

ReactDOM.render(
    <Welcome name="Bob"/>,
    document.getElementById('root')
);

</script>
</body>
</html>
```
## 面向对象编程
### 原型继承
1. 在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。

2. 由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。

3. 但是办法还是有的。我们先回顾

```
function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}
```
4. 以及

5. None

6. 现在，我们要基于

```
function PrimaryStudent(props) {
    // 调用Student构造函数，绑定this变量:
    Student.call(this, props);
    this.grade = props.grade || 1;
}
```
7. 但是，调用了

```
new PrimaryStudent() ----> PrimaryStudent.prototype ----> Object.prototype ----> null
```
8. 必须想办法把原型链修改为：

```
new PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Object.prototype ----> null
```
9. 这样，原型链对了，继承关系就对了。新的基于

10. 如果你想用最简单粗暴的方法这么干：

```
PrimaryStudent.prototype = Student.prototype;
```
11. 是不行的！如果这样的话，

12. 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向

```
// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 空函数F:
function F() {
}

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: '小明',
    grade: 2
});
xiaoming.name; // '小明'
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true
```
13. 用一张图来表示新的原型链：

14. None

15. 注意，函数

16. 如果把继承这个动作用一个

```
function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
```
17. 这个

```
function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
```
#### 小结 
1. JavaScript的原型继承实现方式就是：

2. 


### 创建对象
1. JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。

2. 当我们用

3. 例如，创建一个

```
var arr = [1, 2, 3];
```
4. 其原型链是：

```
arr ----> Array.prototype ----> Object.prototype ----> null
```
5. None

6. 当我们创建一个函数时：

```
function foo() {
    return 0;
}
```
7. 函数也是一个对象，它的原型链是：

```
foo ----> Function.prototype ----> Object.prototype ----> null
```
8. 由于

9. 很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。

#### 构造函数 
1. 除了直接用

```
function Student(name) {
    this.name = name;
    this.hello = function () {
        alert('Hello, ' + this.name + '!');
    }
}
```
2. 你会问，咦，这不是一个普通函数吗？

3. 这确实是一个普通函数，但是在JavaScript中，可以用关键字

```
var xiaoming = new Student('小明');
xiaoming.name; // '小明'
xiaoming.hello(); // Hello, 小明!
```
4. None

5. 新创建的

```
xiaoming ----> Student.prototype ----> Object.prototype ----> null
```
6. 也就是说，

```
xiaoming ↘
xiaohong -→ Student.prototype ----> Object.prototype ----> null
xiaojun  ↗
```
7. 用

```
xiaoming.constructor === Student.prototype.constructor; // true
Student.prototype.constructor === Student; // true

Object.getPrototypeOf(xiaoming) === Student.prototype; // true

xiaoming instanceof Student; // true
```
8. 看晕了吧？用一张图来表示这些乱七八糟的关系就是：

9. None

10. 红色箭头是原型链。注意，

11. 另外，函数

12. 现在我们就认为

13. 不过还有一个小问题，注意观察：

```
xiaoming.name; // '小明'
xiaohong.name; // '小红'
xiaoming.hello; // function: Student.hello()
xiaohong.hello; // function: Student.hello()
xiaoming.hello === xiaohong.hello; // false
```
14. None

15. None

16. 如果我们通过

17. 要让创建的对象共享一个

18. None

19. 修改代码如下：

```
function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};
```
20. 用

#### 忘记写new怎么办 
1. 如果一个函数被定义为用于创建对象的构造函数，但是调用时忘记了写

2. 在strict模式下，

3. 所以，调用构造函数千万不要忘记写

4. 最后，我们还可以编写一个

```
function Student(props) {
    this.name = props.name || '匿名'; // 默认值为'匿名'
    this.grade = props.grade || 1; // 默认值为1
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};

function createStudent(props) {
    return new Student(props || {})
}
```
5. 这个

```
var xiaoming = createStudent({
    name: '小明'
});

xiaoming.grade; // 1
```
6. 如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从

#### 练习 
1. 请利用构造函数定义

```
'use strict';
----
function Cat(name) {
    //
}
----
// 测试:
var kitty = new Cat('Kitty');
var doraemon = new Cat('哆啦A梦');
if (kitty && kitty.name === 'Kitty'
    && kitty.say
    && typeof kitty.say === 'function'
    && kitty.say() === 'Hello, Kitty!'
    && kitty.say === doraemon.say
) {
    console.log('测试通过!');
} else {
    console.log('测试失败!');
}
```
### class继承
1. 在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。

2. 有没有更简单的写法？有！

3. 新的关键字

4. 我们先回顾用函数实现

```
function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}
```
5. 如果用新的

```
class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert('Hello, ' + this.name + '!');
    }
}
```
6. 比较一下就可以发现，

7. 最后，创建一个

```
var xiaoming = new Student('小明');
xiaoming.hello();
```
#### class继承 
1. 用

```
class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}

```
2. 注意

3. None

4. ES6引入的

5. 你一定会问，

6. 现在用还早了点，因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把

#### 练习 
1. 请利用

```
'use strict';

class Animal {
    constructor(name) {
        this.name = name;
    }
}
----
class Cat ???
----
// 测试:
var kitty = new Cat('Kitty');
var doraemon = new Cat('哆啦A梦');
if ((new Cat('x') instanceof Animal)
    && kitty 
    && kitty.name === 'Kitty'
    && kitty.say
    && typeof kitty.say === 'function'
    && kitty.say() === 'Hello, Kitty!'
    && kitty.say === doraemon.say)
{
    console.log('测试通过!');
} else {
    console.log('测试失败!');
}
```
2. 这个练习需要浏览器支持ES6的

## 标准对象
### JSON
1. JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。

2. 在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。

3. 终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。

4. 道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：

5. 


6. 以及上面的任意组合。

7. 并且，JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号

8. 由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。

9. 把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。

10. 如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。

#### 序列化 
1. 让我们先把小明这个对象序列化成JSON格式的字符串：

```
'use strict';

var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp']
};
----
var s = JSON.stringify(xiaoming);
console.log(s);
```
2. 要输出得好看一些，可以加上参数，按缩进输出：

```
JSON.stringify(xiaoming, null, '  ');
```
3. 结果：

```
{
  "name": "小明",
  "age": 14,
  "gender": true,
  "height": 1.65,
  "grade": null,
  "middle-school": "\"W3C\" Middle School",
  "skills": [
    "JavaScript",
    "Java",
    "Python",
    "Lisp"
  ]
}
```
4. 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入

```
JSON.stringify(xiaoming, ['name', 'skills'], '  ');
```
5. 结果：

```
{
  "name": "小明",
  "skills": [
    "JavaScript",
    "Java",
    "Python",
    "Lisp"
  ]
}
```
6. 还可以传入一个函数，这样对象的每个键值对都会被函数先处理：

```
function convert(key, value) {
    if (typeof value === 'string') {
        return value.toUpperCase();
    }
    return value;
}

JSON.stringify(xiaoming, convert, '  ');
```
7. 上面的代码把所有属性值都变成大写：

```
{
  "name": "小明",
  "age": 14,
  "gender": true,
  "height": 1.65,
  "grade": null,
  "middle-school": "\"W3C\" MIDDLE SCHOOL",
  "skills": [
    "JAVASCRIPT",
    "JAVA",
    "PYTHON",
    "LISP"
  ]
}
```
8. 如果我们还想要精确控制如何序列化小明，可以给

```
var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],
    toJSON: function () {
        return { // 只输出name和age，并且改变了key：
            'Name': this.name,
            'Age': this.age
        };
    }
};

JSON.stringify(xiaoming); // '{"Name":"小明","Age":14}'
```
#### 反序列化 
1. 拿到一个JSON格式的字符串，我们直接用

```
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```
2. None

```
'use strict';
----
var obj = JSON.parse('{"name":"小明","age":14}', function (key, value) {
    if (key === 'name') {
        return value + '同学';
    }
    return value;
});
console.log(JSON.stringify(obj)); // {name: '小明同学', age: 14}
```
3. 在JavaScript中使用JSON，就是这么简单！

#### 练习 
1. 用浏览器访问OpenWeatherMap的

```
'use strict'

var url = 'https://api.openweathermap.org/data/2.5/forecast?q=Beijing,cn&appid=800f49846586c3ba6e7052cfc89af16c';
$.getJSON(url, function (data) {
----
    var info = {
        city: data.city.name,
        weather: data.list[0].weather[0].main,
        time: data.list[0].dt_txt
    };
    alert(JSON.stringify(info, null, '  '));
----
});
```
### RegExp
1. 字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取

2. 正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。

3. 所以我们判断一个字符串是否是合法的Email的方法是：

4. 


5. 因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。

6. 在正则表达式中，如果直接给出字符，就是精确匹配。用

7. 


8. None

9. 


10. 要匹配变长的字符，在正则表达式中，用

11. 来看一个复杂的例子：

12. 我们来从左到右解读一下：

13. 


14. 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。

15. 如果要匹配

16. 但是，仍然无法匹配

#### 进阶 
1. 要做更精确地匹配，可以用

2. 


3. None

4. None

5. None

6. 你可能注意到了，

#### RegExp 
1. 有了准备知识，我们就可以在JavaScript中使用正则表达式了。

2. JavaScript有两种方式创建一个正则表达式：

3. 第一种方式是直接通过

4. 两种写法是一样的：

```
var re1 = /ABC\-001/;
var re2 = new RegExp('ABC\\-001');

re1; // /ABC\-001/
re2; // /ABC\-001/
```
5. 注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个

6. 先看看如何判断正则表达式是否匹配：

```
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
re.test('010 12345'); // false
```
7. RegExp对象的

#### 切分字符串 
1. 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：

```
'a b   c'.split(' '); // ['a', 'b', '', '', 'c']
```
2. 嗯，无法识别连续的空格，用正则表达式试试：

```
'a b   c'.split(/\s+/); // ['a', 'b', 'c']
```
3. 无论多少个空格都可以正常分割。加入

```
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
```
4. 再加入

```
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```
5. 如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。

#### 分组 
1. 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用

2. None

```
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```
3. 如果正则表达式中定义了组，就可以在

4. None

5. None

6. 提取子串非常有用。来看一个更凶残的例子：

```
var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
re.exec('19:05:30'); // ['19:05:30', '19', '05', '30']
```
7. 这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：

```
var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;
```
8. 对于

#### 贪婪匹配 
1. 需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的

```
var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
```
2. 由于

3. 必须让

```
var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']
```
#### 全局搜索 
1. JavaScript的正则表达式还有几个特殊的标志，最常用的是

```
var r1 = /test/g;
// 等价于:
var r2 = new RegExp('test', 'g');
```
2. 全局匹配可以多次执行

```
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```
3. 全局匹配类似搜索，因此不能使用

4. 正则表达式还可以指定

#### 小结 
1. 正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书。

#### 练习 
1. 请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email：

```
'use strict';
----
var re = /^$/;
----
// 测试:
var
    i,
    success = true,
    should_pass = ['someone@gmail.com', 'bill.gates@microsoft.com', 'tom@voyager.org', 'bob2015@163.com'],
    should_fail = ['test#gmail.com', 'bill@microsoft', 'bill%gates@ms.com', '@voyager.org'];
for (i = 0; i < should_pass.length; i++) {
    if (!re.test(should_pass[i])) {
        console.log('测试失败: ' + should_pass[i]);
        success = false;
        break;
    }
}
for (i = 0; i < should_fail.length; i++) {
    if (re.test(should_fail[i])) {
        console.log('测试失败: ' + should_fail[i]);
        success = false;
        break;
    }
}
if (success) {
    console.log('测试通过!');
}
```
2. 版本二可以验证并提取出带名字的Email地址：

```
'use strict';
----
var re = /^$/;
----
// 测试:
var r = re.exec('<Tom Paris> tom@voyager.org');
if (r === null || r.toString() !== ['<Tom Paris> tom@voyager.org', 'Tom Paris', 'tom@voyager.org'].toString()) {
    console.log('测试失败!');
}
else {
    console.log('测试成功!');
}
```
### Date
1. 在JavaScript中，

2. 要获取系统当前时间，用：

```
var now = new Date();
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```
3. 注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。

4. 如果要创建一个指定日期和时间的

```
var d = new Date(2015, 5, 19, 20, 15, 30, 123);
d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)
```
5. 你可能观察到了一个

```
JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。
```
6. 第二种创建一个指定日期和时间的方法是解析一个符合

```
var d = Date.parse('2015-06-24T19:49:22.875+08:00');
d; // 1435146562875
```
7. 但它返回的不是

```
var d = new Date(1435146562875);
d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
d.getMonth(); // 5
```
```
使用Date.parse()时传入的字符串使用实际月份01~12，转换为Date对象后getMonth()获取的月份值为0~11。
```
#### 时区 
1. None

```
var d = new Date(1435146562875);
d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时
```
2. 那么在JavaScript中如何进行时区转换呢？实际上，只要我们传递的是一个

3. 时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。

4. 所以，我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。

5. 要获取当前时间戳，可以用：

```
'use strict';
----
if (Date.now) {
    console.log(Date.now()); // 老版本IE没有now()方法
} else {
    console.log(new Date().getTime());
}
```
#### 练习 
1. 小明为了和女友庆祝情人节，特意制作了网页，并提前预定了法式餐厅。小明打算用JavaScript给女友一个惊喜留言：

```
'use strict';
----
var today = new Date();
if (today.getMonth() === 2 && today.getDate() === 14) {
    alert('亲爱的，我预定了晚餐，晚上6点在餐厅见！');
}
```
2. 结果女友并未出现。小明非常郁闷，请你帮忙分析他的JavaScript代码有何问题。

3. None

